Performing "debug" build using dmd for x86.
svd_to_d_reg ~master: building configuration "application"...
Linking...
Running .\build\svd_to_d_reg.exe MKL25Z4.svd
/****************************************************************************************
  * Flash configuration field
*/
final abstract class FTFA_FlashConfig: Peripheral!(0x400)
{
  /**************************************************************************************
  * Backdoor Comparison Key 3.
  */
  final abstract class BACKKEY3  : Register!(0  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 2.
  */
  final abstract class BACKKEY2  : Register!(0x1  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 1.
  */
  final abstract class BACKKEY1  : Register!(0x2  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 0.
  */
  final abstract class BACKKEY0  : Register!(0x3  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 7.
  */
  final abstract class BACKKEY7  : Register!(0x4  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 6.
  */
  final abstract class BACKKEY6  : Register!(0x5  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 5.
  */
  final abstract class BACKKEY5  : Register!(0x6  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Backdoor Comparison Key 4.
  */
  final abstract class BACKKEY4  : Register!(0x7  , Access.read_only8)
  {
    /************************************************************************************
    Backdoor Comparison Key.
    */
    alias KEY =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile P-Flash Protection 1 - Low Register
  */
  final abstract class FPROT3  : Register!(0x8  , Access.read_only8)
  {
    /************************************************************************************
    P-Flash Region Protect
    */
    alias PROT =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile P-Flash Protection 1 - High Register
  */
  final abstract class FPROT2  : Register!(0x9  , Access.read_only8)
  {
    /************************************************************************************
    P-Flash Region Protect
    */
    alias PROT =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile P-Flash Protection 0 - Low Register
  */
  final abstract class FPROT1  : Register!(0xA  , Access.read_only8)
  {
    /************************************************************************************
    P-Flash Region Protect
    */
    alias PROT =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile P-Flash Protection 0 - High Register
  */
  final abstract class FPROT0  : Register!(0xB  , Access.read_only8)
  {
    /************************************************************************************
    P-Flash Region Protect
    */
    alias PROT =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile Flash Security Register
  */
  final abstract class FSEC  : Register!(0xC  , Access.read_only8)
  {
    /************************************************************************************
    Flash Security
      10  #10  MCU security status is unsecure
      11  #11  MCU security status is secure
    */
    alias SEC =   BitField!(2, 0, Mutability.read_only);

    /************************************************************************************
    Freescale Failure Analysis Access Code
      10  #10  Freescale factory access denied
      11  #11  Freescale factory access granted
    */
    alias FSLACC =   BitField!(4, 2, Mutability.read_only);

    /************************************************************************************
    no description available
      10  #10  Mass erase is disabled
      11  #11  Mass erase is enabled
    */
    alias MEEN =   BitField!(6, 4, Mutability.read_only);

    /************************************************************************************
    Backdoor Key Security Enable
      10  #10  Backdoor key access enabled
      11  #11  Backdoor key access disabled
    */
    alias KEYEN =   BitField!(8, 6, Mutability.read_only);

  }
  /**************************************************************************************
  * Non-volatile Flash Option Register
  */
  final abstract class FOPT  : Register!(0xD  , Access.read_only8)
  {
    /************************************************************************************
    no description available
      00  #00  Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when LPBOOT1=0 or 0x1 (divide by 2) when LPBOOT1=1.
      01  #01  Core and system clock divider (OUTDIV1) is 0x3 (divide by 4) when LPBOOT1=0 or 0x0 (divide by 1) when LPBOOT1=1.
    */
    alias LPBOOT0 =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    no description available
      00  #00  NMI interrupts are always blocked
      01  #01  NMI_b pin/interrupts reset default to enabled
    */
    alias NMI_DIS =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    no description available
      00  #00  RESET pin is disabled following a POR and cannot be enabled as reset function
      01  #01  RESET_b pin is dedicated
    */
    alias RESET_PIN_CFG =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    no description available
      00  #00  Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when LPBOOT0=0 or 0x3 (divide by 4) when LPBOOT0=1.
      01  #01  Core and system clock divider (OUTDIV1) is 0x1 (divide by 2) when LPBOOT0=0 or 0x0 (divide by 1) when LPBOOT0=1.
    */
    alias LPBOOT1 =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    no description available
      00  #00  Slower initialization
      01  #01  Fast Initialization
    */
    alias FAST_INIT =   Bit!(6, Mutability.read_only);

  }
}
/****************************************************************************************
  * DMA Controller
*/
final abstract class DMA: Peripheral!(0x40008000)
{
  /**************************************************************************************
  * Source Address Register
  */
  final abstract class SAR0  : Register!(0X100  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias SAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Source Address Register
  */
  final abstract class SAR1  : Register!(0X110  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias SAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Source Address Register
  */
  final abstract class SAR2  : Register!(0X120  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias SAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Source Address Register
  */
  final abstract class SAR3  : Register!(0X130  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias SAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Destination Address Register
  */
  final abstract class DAR0  : Register!(0X104  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias DAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Destination Address Register
  */
  final abstract class DAR1  : Register!(0X114  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias DAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Destination Address Register
  */
  final abstract class DAR2  : Register!(0X124  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias DAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Destination Address Register
  */
  final abstract class DAR3  : Register!(0X134  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias DAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * DMA Status Register / Byte Count Register
  */
  final abstract class DSR_BCR0  : Register!(0X108  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias BCR =   BitField!(24, 0, Mutability.read_write);

    /************************************************************************************
    Transactions done
      0  #0  DMA transfer is not yet complete. Writing a 0 has no effect.
      1  #1  DMA transfer completed. Writing a 1 to this bit clears all DMA status bits and should be used in an interrupt service routine to clear the DMA interrupt and error bits.
    */
    alias DONE =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    Busy
      0  #0  DMA channel is inactive. Cleared when the DMA has finished the last transaction.
      1  #1  BSY is set the first time the channel is enabled after a transfer is initiated.
    */
    alias BSY =   Bit!(26, Mutability.read_only);

    /************************************************************************************
    Request
      0  #0  No request is pending or the channel is currently active. Cleared when the channel is selected.
      1  #1  The DMA channel has a transfer remaining and the channel is not selected.
    */
    alias REQ =   Bit!(27, Mutability.read_only);

    /************************************************************************************
    Bus error on destination
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the write portion of a transfer.
    */
    alias BED =   Bit!(29, Mutability.read_only);

    /************************************************************************************
    Bus error on source
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the read portion of a transfer.
    */
    alias BES =   Bit!(30, Mutability.read_only);

    /************************************************************************************
    Configuration error
      0  #0  No configuration error exists.
      1  #1  A configuration error has occurred.
    */
    alias CE =   Bit!(31, Mutability.read_only);

  }
  /**************************************************************************************
  * DMA Status Register / Byte Count Register
  */
  final abstract class DSR_BCR1  : Register!(0X118  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias BCR =   BitField!(24, 0, Mutability.read_write);

    /************************************************************************************
    Transactions done
      0  #0  DMA transfer is not yet complete. Writing a 0 has no effect.
      1  #1  DMA transfer completed. Writing a 1 to this bit clears all DMA status bits and should be used in an interrupt service routine to clear the DMA interrupt and error bits.
    */
    alias DONE =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    Busy
      0  #0  DMA channel is inactive. Cleared when the DMA has finished the last transaction.
      1  #1  BSY is set the first time the channel is enabled after a transfer is initiated.
    */
    alias BSY =   Bit!(26, Mutability.read_only);

    /************************************************************************************
    Request
      0  #0  No request is pending or the channel is currently active. Cleared when the channel is selected.
      1  #1  The DMA channel has a transfer remaining and the channel is not selected.
    */
    alias REQ =   Bit!(27, Mutability.read_only);

    /************************************************************************************
    Bus error on destination
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the write portion of a transfer.
    */
    alias BED =   Bit!(29, Mutability.read_only);

    /************************************************************************************
    Bus error on source
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the read portion of a transfer.
    */
    alias BES =   Bit!(30, Mutability.read_only);

    /************************************************************************************
    Configuration error
      0  #0  No configuration error exists.
      1  #1  A configuration error has occurred.
    */
    alias CE =   Bit!(31, Mutability.read_only);

  }
  /**************************************************************************************
  * DMA Status Register / Byte Count Register
  */
  final abstract class DSR_BCR2  : Register!(0X128  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias BCR =   BitField!(24, 0, Mutability.read_write);

    /************************************************************************************
    Transactions done
      0  #0  DMA transfer is not yet complete. Writing a 0 has no effect.
      1  #1  DMA transfer completed. Writing a 1 to this bit clears all DMA status bits and should be used in an interrupt service routine to clear the DMA interrupt and error bits.
    */
    alias DONE =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    Busy
      0  #0  DMA channel is inactive. Cleared when the DMA has finished the last transaction.
      1  #1  BSY is set the first time the channel is enabled after a transfer is initiated.
    */
    alias BSY =   Bit!(26, Mutability.read_only);

    /************************************************************************************
    Request
      0  #0  No request is pending or the channel is currently active. Cleared when the channel is selected.
      1  #1  The DMA channel has a transfer remaining and the channel is not selected.
    */
    alias REQ =   Bit!(27, Mutability.read_only);

    /************************************************************************************
    Bus error on destination
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the write portion of a transfer.
    */
    alias BED =   Bit!(29, Mutability.read_only);

    /************************************************************************************
    Bus error on source
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the read portion of a transfer.
    */
    alias BES =   Bit!(30, Mutability.read_only);

    /************************************************************************************
    Configuration error
      0  #0  No configuration error exists.
      1  #1  A configuration error has occurred.
    */
    alias CE =   Bit!(31, Mutability.read_only);

  }
  /**************************************************************************************
  * DMA Status Register / Byte Count Register
  */
  final abstract class DSR_BCR3  : Register!(0X138  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias BCR =   BitField!(24, 0, Mutability.read_write);

    /************************************************************************************
    Transactions done
      0  #0  DMA transfer is not yet complete. Writing a 0 has no effect.
      1  #1  DMA transfer completed. Writing a 1 to this bit clears all DMA status bits and should be used in an interrupt service routine to clear the DMA interrupt and error bits.
    */
    alias DONE =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    Busy
      0  #0  DMA channel is inactive. Cleared when the DMA has finished the last transaction.
      1  #1  BSY is set the first time the channel is enabled after a transfer is initiated.
    */
    alias BSY =   Bit!(26, Mutability.read_only);

    /************************************************************************************
    Request
      0  #0  No request is pending or the channel is currently active. Cleared when the channel is selected.
      1  #1  The DMA channel has a transfer remaining and the channel is not selected.
    */
    alias REQ =   Bit!(27, Mutability.read_only);

    /************************************************************************************
    Bus error on destination
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the write portion of a transfer.
    */
    alias BED =   Bit!(29, Mutability.read_only);

    /************************************************************************************
    Bus error on source
      0  #0  No bus error occurred.
      1  #1  The DMA channel terminated with a bus error during the read portion of a transfer.
    */
    alias BES =   Bit!(30, Mutability.read_only);

    /************************************************************************************
    Configuration error
      0  #0  No configuration error exists.
      1  #1  A configuration error has occurred.
    */
    alias CE =   Bit!(31, Mutability.read_only);

  }
  /**************************************************************************************
  * DMA_DSR0 register.
  */
  final abstract class DSR0  : Register!(0x10B  , Access.read_write8)
  {
  }
  /**************************************************************************************
  * DMA Control Register
  */
  final abstract class DCR0  : Register!(0X10C  , Access.read_write32)
  {
    /************************************************************************************
    Link channel 2
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH2 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Link channel 1
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH1 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Link channel control
      00  #00  No channel-to-channel linking
      01  #01  Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2 after the BCR decrements to zero
      10  #10  Perform a link to channel LCH1 after each cycle-steal transfer
      11  #11  Perform a link to channel LCH1 after the BCR decrements to zero
    */
    alias LINKCC =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Disable request
      0  #0  ERQ bit is not affected.
      1  #1  ERQ bit is cleared when the BCR is exhausted.
    */
    alias D_REQ =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    Destination address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias DMOD =   BitField!(12, 8, Mutability.read_write);

    /************************************************************************************
    Source address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias SMOD =   BitField!(16, 12, Mutability.read_write);

    /************************************************************************************
    Start transfer
      0  #0  DMA inactive
      1  #1  The DMA begins the transfer in accordance to the values in the TCDn. START is cleared automatically after one module clock and always reads as logic 0.
    */
    alias START =   Bit!(17, Mutability.write_only);

    /************************************************************************************
    Destination size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias DSIZE =   BitField!(19, 17, Mutability.read_write);

    /************************************************************************************
    Destination increment
      0  #0  No change to the DAR after a successful transfer.
      1  #1  The DAR increments by 1, 2, 4 depending upon the size of the transfer.
    */
    alias DINC =   Bit!(20, Mutability.read_write);

    /************************************************************************************
    Source size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias SSIZE =   BitField!(22, 20, Mutability.read_write);

    /************************************************************************************
    Source increment
      0  #0  No change to SAR after a successful transfer.
      1  #1  The SAR increments by 1, 2, 4 as determined by the transfer size.
    */
    alias SINC =   Bit!(23, Mutability.read_write);

    /************************************************************************************
    Enable asynchronous DMA requests
      0  #0  Disabled
      1  #1  Enabled
    */
    alias EADREQ =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    Auto-align
      0  #0  Auto-align disabled
      1  #1  If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned; otherwise, destination accesses are auto-aligned. Source alignment takes precedence over destination alignment. If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC.
    */
    alias AA =   Bit!(29, Mutability.read_write);

    /************************************************************************************
    Cycle steal
      0  #0  DMA continuously makes read/write transfers until the BCR decrements to 0.
      1  #1  Forces a single read/write transfer per request.
    */
    alias CS =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    Enable peripheral request
      0  #0  Peripheral request is ignored.
      1  #1  Enables peripheral request to initiate transfer. A software-initiated request (setting the START bit) is always enabled.
    */
    alias ERQ =   Bit!(31, Mutability.read_write);

    /************************************************************************************
    Enable interrupt on completion of transfer
      0  #0  No interrupt is generated.
      1  #1  Interrupt signal is enabled.
    */
    alias EINT =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * DMA Control Register
  */
  final abstract class DCR1  : Register!(0X11C  , Access.read_write32)
  {
    /************************************************************************************
    Link channel 2
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH2 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Link channel 1
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH1 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Link channel control
      00  #00  No channel-to-channel linking
      01  #01  Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2 after the BCR decrements to zero
      10  #10  Perform a link to channel LCH1 after each cycle-steal transfer
      11  #11  Perform a link to channel LCH1 after the BCR decrements to zero
    */
    alias LINKCC =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Disable request
      0  #0  ERQ bit is not affected.
      1  #1  ERQ bit is cleared when the BCR is exhausted.
    */
    alias D_REQ =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    Destination address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias DMOD =   BitField!(12, 8, Mutability.read_write);

    /************************************************************************************
    Source address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias SMOD =   BitField!(16, 12, Mutability.read_write);

    /************************************************************************************
    Start transfer
      0  #0  DMA inactive
      1  #1  The DMA begins the transfer in accordance to the values in the TCDn. START is cleared automatically after one module clock and always reads as logic 0.
    */
    alias START =   Bit!(17, Mutability.write_only);

    /************************************************************************************
    Destination size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias DSIZE =   BitField!(19, 17, Mutability.read_write);

    /************************************************************************************
    Destination increment
      0  #0  No change to the DAR after a successful transfer.
      1  #1  The DAR increments by 1, 2, 4 depending upon the size of the transfer.
    */
    alias DINC =   Bit!(20, Mutability.read_write);

    /************************************************************************************
    Source size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias SSIZE =   BitField!(22, 20, Mutability.read_write);

    /************************************************************************************
    Source increment
      0  #0  No change to SAR after a successful transfer.
      1  #1  The SAR increments by 1, 2, 4 as determined by the transfer size.
    */
    alias SINC =   Bit!(23, Mutability.read_write);

    /************************************************************************************
    Enable asynchronous DMA requests
      0  #0  Disabled
      1  #1  Enabled
    */
    alias EADREQ =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    Auto-align
      0  #0  Auto-align disabled
      1  #1  If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned; otherwise, destination accesses are auto-aligned. Source alignment takes precedence over destination alignment. If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC.
    */
    alias AA =   Bit!(29, Mutability.read_write);

    /************************************************************************************
    Cycle steal
      0  #0  DMA continuously makes read/write transfers until the BCR decrements to 0.
      1  #1  Forces a single read/write transfer per request.
    */
    alias CS =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    Enable peripheral request
      0  #0  Peripheral request is ignored.
      1  #1  Enables peripheral request to initiate transfer. A software-initiated request (setting the START bit) is always enabled.
    */
    alias ERQ =   Bit!(31, Mutability.read_write);

    /************************************************************************************
    Enable interrupt on completion of transfer
      0  #0  No interrupt is generated.
      1  #1  Interrupt signal is enabled.
    */
    alias EINT =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * DMA Control Register
  */
  final abstract class DCR2  : Register!(0X12C  , Access.read_write32)
  {
    /************************************************************************************
    Link channel 2
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH2 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Link channel 1
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH1 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Link channel control
      00  #00  No channel-to-channel linking
      01  #01  Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2 after the BCR decrements to zero
      10  #10  Perform a link to channel LCH1 after each cycle-steal transfer
      11  #11  Perform a link to channel LCH1 after the BCR decrements to zero
    */
    alias LINKCC =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Disable request
      0  #0  ERQ bit is not affected.
      1  #1  ERQ bit is cleared when the BCR is exhausted.
    */
    alias D_REQ =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    Destination address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias DMOD =   BitField!(12, 8, Mutability.read_write);

    /************************************************************************************
    Source address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias SMOD =   BitField!(16, 12, Mutability.read_write);

    /************************************************************************************
    Start transfer
      0  #0  DMA inactive
      1  #1  The DMA begins the transfer in accordance to the values in the TCDn. START is cleared automatically after one module clock and always reads as logic 0.
    */
    alias START =   Bit!(17, Mutability.write_only);

    /************************************************************************************
    Destination size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias DSIZE =   BitField!(19, 17, Mutability.read_write);

    /************************************************************************************
    Destination increment
      0  #0  No change to the DAR after a successful transfer.
      1  #1  The DAR increments by 1, 2, 4 depending upon the size of the transfer.
    */
    alias DINC =   Bit!(20, Mutability.read_write);

    /************************************************************************************
    Source size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias SSIZE =   BitField!(22, 20, Mutability.read_write);

    /************************************************************************************
    Source increment
      0  #0  No change to SAR after a successful transfer.
      1  #1  The SAR increments by 1, 2, 4 as determined by the transfer size.
    */
    alias SINC =   Bit!(23, Mutability.read_write);

    /************************************************************************************
    Enable asynchronous DMA requests
      0  #0  Disabled
      1  #1  Enabled
    */
    alias EADREQ =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    Auto-align
      0  #0  Auto-align disabled
      1  #1  If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned; otherwise, destination accesses are auto-aligned. Source alignment takes precedence over destination alignment. If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC.
    */
    alias AA =   Bit!(29, Mutability.read_write);

    /************************************************************************************
    Cycle steal
      0  #0  DMA continuously makes read/write transfers until the BCR decrements to 0.
      1  #1  Forces a single read/write transfer per request.
    */
    alias CS =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    Enable peripheral request
      0  #0  Peripheral request is ignored.
      1  #1  Enables peripheral request to initiate transfer. A software-initiated request (setting the START bit) is always enabled.
    */
    alias ERQ =   Bit!(31, Mutability.read_write);

    /************************************************************************************
    Enable interrupt on completion of transfer
      0  #0  No interrupt is generated.
      1  #1  Interrupt signal is enabled.
    */
    alias EINT =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * DMA Control Register
  */
  final abstract class DCR3  : Register!(0X13C  , Access.read_write32)
  {
    /************************************************************************************
    Link channel 2
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH2 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Link channel 1
      00  #00  DMA Channel 0
      01  #01  DMA Channel 1
      10  #10  DMA Channel 2
      11  #11  DMA Channel 3
    */
    alias LCH1 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Link channel control
      00  #00  No channel-to-channel linking
      01  #01  Perform a link to channel LCH1 after each cycle-steal transfer followed by a link to LCH2 after the BCR decrements to zero
      10  #10  Perform a link to channel LCH1 after each cycle-steal transfer
      11  #11  Perform a link to channel LCH1 after the BCR decrements to zero
    */
    alias LINKCC =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Disable request
      0  #0  ERQ bit is not affected.
      1  #1  ERQ bit is cleared when the BCR is exhausted.
    */
    alias D_REQ =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    Destination address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias DMOD =   BitField!(12, 8, Mutability.read_write);

    /************************************************************************************
    Source address modulo
      0000  #0000  Buffer disabled
      0001  #0001  Circular buffer size is 16 bytes
      0010  #0010  Circular buffer size is 32 bytes
      0011  #0011  Circular buffer size is 64 bytes
      0100  #0100  Circular buffer size is 128 bytes
      0101  #0101  Circular buffer size is 256 bytes
      0110  #0110  Circular buffer size is 512 bytes
      0111  #0111  Circular buffer size is 1 KB
      1000  #1000  Circular buffer size is 2 KB
      1001  #1001  Circular buffer size is 4 KB
      1010  #1010  Circular buffer size is 8 KB
      1011  #1011  Circular buffer size is 16 KB
      1100  #1100  Circular buffer size is 32 KB
      1101  #1101  Circular buffer size is 64 KB
      1110  #1110  Circular buffer size is 128 KB
      1111  #1111  Circular buffer size is 256 KB
    */
    alias SMOD =   BitField!(16, 12, Mutability.read_write);

    /************************************************************************************
    Start transfer
      0  #0  DMA inactive
      1  #1  The DMA begins the transfer in accordance to the values in the TCDn. START is cleared automatically after one module clock and always reads as logic 0.
    */
    alias START =   Bit!(17, Mutability.write_only);

    /************************************************************************************
    Destination size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias DSIZE =   BitField!(19, 17, Mutability.read_write);

    /************************************************************************************
    Destination increment
      0  #0  No change to the DAR after a successful transfer.
      1  #1  The DAR increments by 1, 2, 4 depending upon the size of the transfer.
    */
    alias DINC =   Bit!(20, Mutability.read_write);

    /************************************************************************************
    Source size
      00  #00  32-bit
      01  #01  8-bit
      10  #10  16-bit
      11  #11  Reserved (generates a configuration error (DSRn[CE]) if incorrectly specified at time of channel activation)
    */
    alias SSIZE =   BitField!(22, 20, Mutability.read_write);

    /************************************************************************************
    Source increment
      0  #0  No change to SAR after a successful transfer.
      1  #1  The SAR increments by 1, 2, 4 as determined by the transfer size.
    */
    alias SINC =   Bit!(23, Mutability.read_write);

    /************************************************************************************
    Enable asynchronous DMA requests
      0  #0  Disabled
      1  #1  Enabled
    */
    alias EADREQ =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    Auto-align
      0  #0  Auto-align disabled
      1  #1  If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned; otherwise, destination accesses are auto-aligned. Source alignment takes precedence over destination alignment. If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC.
    */
    alias AA =   Bit!(29, Mutability.read_write);

    /************************************************************************************
    Cycle steal
      0  #0  DMA continuously makes read/write transfers until the BCR decrements to 0.
      1  #1  Forces a single read/write transfer per request.
    */
    alias CS =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    Enable peripheral request
      0  #0  Peripheral request is ignored.
      1  #1  Enables peripheral request to initiate transfer. A software-initiated request (setting the START bit) is always enabled.
    */
    alias ERQ =   Bit!(31, Mutability.read_write);

    /************************************************************************************
    Enable interrupt on completion of transfer
      0  #0  No interrupt is generated.
      1  #1  Interrupt signal is enabled.
    */
    alias EINT =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * DMA_DSR1 register.
  */
  final abstract class DSR1  : Register!(0x11B  , Access.read_write8)
  {
  }
  /**************************************************************************************
  * DMA_DSR2 register.
  */
  final abstract class DSR2  : Register!(0x12B  , Access.read_write8)
  {
  }
  /**************************************************************************************
  * DMA_DSR3 register.
  */
  final abstract class DSR3  : Register!(0x13B  , Access.read_write8)
  {
  }
}
/****************************************************************************************
  * Flash Memory Interface
*/
final abstract class FTFA: Peripheral!(0x40020000)
{
  /**************************************************************************************
  * Flash Status Register
  */
  final abstract class FSTAT  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Memory Controller Command Completion Status Flag
    */
    alias MGSTAT0 =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Flash Protection Violation Flag
      0  #0  No protection violation detected
      1  #1  Protection violation detected
    */
    alias FPVIOL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Flash Access Error Flag
      0  #0  No access error detected
      1  #1  Access error detected
    */
    alias ACCERR =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Flash Read Collision Error Flag
      0  #0  No collision error detected
      1  #1  Collision error detected
    */
    alias RDCOLERR =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Command Complete Interrupt Flag
      0  #0  Flash command in progress
      1  #1  Flash command has completed
    */
    alias CCIF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Configuration Register
  */
  final abstract class FCNFG  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Erase Suspend
      0  #0  No suspend requested
      1  #1  Suspend the current Erase Flash Sector command execution.
    */
    alias ERSSUSP =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Erase All Request
      0  #0  No request or request complete
      1  #1  Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC[SEC] field to the unsecure state.
    */
    alias ERSAREQ =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Read Collision Error Interrupt Enable
      0  #0  Read collision error interrupt disabled
      1  #1  Read collision error interrupt enabled. An interrupt request is generated whenever a flash memory read collision error is detected (see the description of FSTAT[RDCOLERR]).
    */
    alias RDCOLLIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Command Complete Interrupt Enable
      0  #0  Command complete interrupt disabled
      1  #1  Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT[CCIF] flag is set.
    */
    alias CCIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Security Register
  */
  final abstract class FSEC  : Register!(0x2  , Access.read_only8)
  {
    /************************************************************************************
    Flash Security
      00  #00  MCU security status is secure
      01  #01  MCU security status is secure
      10  #10  MCU security status is unsecure (The standard shipping condition of the flash memory module is unsecure.)
      11  #11  MCU security status is secure
    */
    alias SEC =   BitField!(2, 0, Mutability.read_only);

    /************************************************************************************
    Freescale Failure Analysis Access Code
      00  #00  Freescale factory access granted
      01  #01  Freescale factory access denied
      10  #10  Freescale factory access denied
      11  #11  Freescale factory access granted
    */
    alias FSLACC =   BitField!(4, 2, Mutability.read_only);

    /************************************************************************************
    Mass Erase Enable Bits
      00  #00  Mass erase is enabled
      01  #01  Mass erase is enabled
      10  #10  Mass erase is disabled
      11  #11  Mass erase is enabled
    */
    alias MEEN =   BitField!(6, 4, Mutability.read_only);

    /************************************************************************************
    Backdoor Key Security Enable
      00  #00  Backdoor key access disabled
      01  #01  Backdoor key access disabled (preferred KEYEN state to disable backdoor key access)
      10  #10  Backdoor key access enabled
      11  #11  Backdoor key access disabled
    */
    alias KEYEN =   BitField!(8, 6, Mutability.read_only);

  }
  /**************************************************************************************
  * Flash Option Register
  */
  final abstract class FOPT  : Register!(0x3  , Access.read_only8)
  {
    /************************************************************************************
    Nonvolatile Option
    */
    alias OPT =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB3  : Register!(0X4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB2  : Register!(0X5  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB1  : Register!(0X6  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB0  : Register!(0X7  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB7  : Register!(0X8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB6  : Register!(0X9  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB5  : Register!(0XA  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB4  : Register!(0XB  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOBB  : Register!(0XC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOBA  : Register!(0XD  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB9  : Register!(0XE  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Common Command Object Registers
  */
  final abstract class FCCOB8  : Register!(0XF  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CCOBn =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Program Flash Protection Registers
  */
  final abstract class FPROT3  : Register!(0X10  , Access.read_write8)
  {
    /************************************************************************************
    Program Flash Region Protect
      0  #0  Program flash region is protected.
      1  #1  Program flash region is not protected
    */
    alias PROT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Program Flash Protection Registers
  */
  final abstract class FPROT2  : Register!(0X11  , Access.read_write8)
  {
    /************************************************************************************
    Program Flash Region Protect
      0  #0  Program flash region is protected.
      1  #1  Program flash region is not protected
    */
    alias PROT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Program Flash Protection Registers
  */
  final abstract class FPROT1  : Register!(0X12  , Access.read_write8)
  {
    /************************************************************************************
    Program Flash Region Protect
      0  #0  Program flash region is protected.
      1  #1  Program flash region is not protected
    */
    alias PROT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Program Flash Protection Registers
  */
  final abstract class FPROT0  : Register!(0X13  , Access.read_write8)
  {
    /************************************************************************************
    Program Flash Region Protect
      0  #0  Program flash region is protected.
      1  #1  Program flash region is not protected
    */
    alias PROT =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * DMA channel multiplexor
*/
final abstract class DMAMUX0: Peripheral!(0x40021000)
{
  /**************************************************************************************
  * Channel Configuration register
  */
  final abstract class CHCFG0  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    DMA Channel Source (Slot)
    */
    alias SOURCE =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    DMA Channel Trigger Enable
      0  #0  Triggering is disabled. If triggering is disabled, and the ENBL bit is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
      1  #1  Triggering is enabled. If triggering is enabled, and the ENBL bit is set, the DMAMUX is in Periodic Trigger mode.
    */
    alias TRIG =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DMA Channel Enable
      0  #0  DMA channel is disabled. This mode is primarily used during configuration of the DMA Mux. The DMA has separate channel enables/disables, which should be used to disable or re-configure a DMA channel.
      1  #1  DMA channel is enabled
    */
    alias ENBL =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel Configuration register
  */
  final abstract class CHCFG1  : Register!(0X1  , Access.read_write8)
  {
    /************************************************************************************
    DMA Channel Source (Slot)
    */
    alias SOURCE =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    DMA Channel Trigger Enable
      0  #0  Triggering is disabled. If triggering is disabled, and the ENBL bit is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
      1  #1  Triggering is enabled. If triggering is enabled, and the ENBL bit is set, the DMAMUX is in Periodic Trigger mode.
    */
    alias TRIG =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DMA Channel Enable
      0  #0  DMA channel is disabled. This mode is primarily used during configuration of the DMA Mux. The DMA has separate channel enables/disables, which should be used to disable or re-configure a DMA channel.
      1  #1  DMA channel is enabled
    */
    alias ENBL =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel Configuration register
  */
  final abstract class CHCFG2  : Register!(0X2  , Access.read_write8)
  {
    /************************************************************************************
    DMA Channel Source (Slot)
    */
    alias SOURCE =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    DMA Channel Trigger Enable
      0  #0  Triggering is disabled. If triggering is disabled, and the ENBL bit is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
      1  #1  Triggering is enabled. If triggering is enabled, and the ENBL bit is set, the DMAMUX is in Periodic Trigger mode.
    */
    alias TRIG =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DMA Channel Enable
      0  #0  DMA channel is disabled. This mode is primarily used during configuration of the DMA Mux. The DMA has separate channel enables/disables, which should be used to disable or re-configure a DMA channel.
      1  #1  DMA channel is enabled
    */
    alias ENBL =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel Configuration register
  */
  final abstract class CHCFG3  : Register!(0X3  , Access.read_write8)
  {
    /************************************************************************************
    DMA Channel Source (Slot)
    */
    alias SOURCE =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    DMA Channel Trigger Enable
      0  #0  Triggering is disabled. If triggering is disabled, and the ENBL bit is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
      1  #1  Triggering is enabled. If triggering is enabled, and the ENBL bit is set, the DMAMUX is in Periodic Trigger mode.
    */
    alias TRIG =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DMA Channel Enable
      0  #0  DMA channel is disabled. This mode is primarily used during configuration of the DMA Mux. The DMA has separate channel enables/disables, which should be used to disable or re-configure a DMA channel.
      1  #1  DMA channel is enabled
    */
    alias ENBL =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Periodic Interrupt Timer
*/
final abstract class PIT: Peripheral!(0x40037000)
{
  /**************************************************************************************
  * PIT Module Control Register
  */
  final abstract class MCR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Freeze
      0  #0  Timers continue to run in Debug mode.
      1  #1  Timers are stopped in Debug mode.
    */
    alias FRZ =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Module Disable - (PIT section)
      0  #0  Clock for standard PIT timers is enabled.
      1  #1  Clock for standard PIT timers is disabled.
    */
    alias MDIS =   Bit!(2, Mutability.read_write);

  }
  /**************************************************************************************
  * PIT Upper Lifetime Timer Register
  */
  final abstract class LTMR64H  : Register!(0xE0  , Access.read_only32)
  {
    /************************************************************************************
    Life Timer value
    */
    alias LTH =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * PIT Lower Lifetime Timer Register
  */
  final abstract class LTMR64L  : Register!(0xE4  , Access.read_only32)
  {
    /************************************************************************************
    Life Timer value
    */
    alias LTL =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Timer Load Value Register
  */
  final abstract class LDVAL0  : Register!(0X100  , Access.read_write32)
  {
    /************************************************************************************
    Timer Start Value
    */
    alias TSV =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Timer Load Value Register
  */
  final abstract class LDVAL1  : Register!(0X110  , Access.read_write32)
  {
    /************************************************************************************
    Timer Start Value
    */
    alias TSV =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Current Timer Value Register
  */
  final abstract class CVAL0  : Register!(0X104  , Access.read_only32)
  {
    /************************************************************************************
    Current Timer Value
    */
    alias TVL =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Current Timer Value Register
  */
  final abstract class CVAL1  : Register!(0X114  , Access.read_only32)
  {
    /************************************************************************************
    Current Timer Value
    */
    alias TVL =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Timer Control Register
  */
  final abstract class TCTRL0  : Register!(0X108  , Access.read_write32)
  {
    /************************************************************************************
    Timer Enable
      0  #0  Timer n is disabled.
      1  #1  Timer n is enabled.
    */
    alias TEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Timer Interrupt Enable
      0  #0  Interrupt requests from Timer n are disabled.
      1  #1  Interrupt will be requested whenever TIF is set.
    */
    alias TIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Chain Mode
      0  #0  Timer is not chained.
      1  #1  Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.
    */
    alias CHN =   Bit!(3, Mutability.read_write);

  }
  /**************************************************************************************
  * Timer Control Register
  */
  final abstract class TCTRL1  : Register!(0X118  , Access.read_write32)
  {
    /************************************************************************************
    Timer Enable
      0  #0  Timer n is disabled.
      1  #1  Timer n is enabled.
    */
    alias TEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Timer Interrupt Enable
      0  #0  Interrupt requests from Timer n are disabled.
      1  #1  Interrupt will be requested whenever TIF is set.
    */
    alias TIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Chain Mode
      0  #0  Timer is not chained.
      1  #1  Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.
    */
    alias CHN =   Bit!(3, Mutability.read_write);

  }
  /**************************************************************************************
  * Timer Flag Register
  */
  final abstract class TFLG0  : Register!(0X10C  , Access.read_write32)
  {
    /************************************************************************************
    Timer Interrupt Flag
      0  #0  Timeout has not yet occurred.
      1  #1  Timeout has occurred.
    */
    alias TIF =   Bit!(1, Mutability.read_write);

  }
  /**************************************************************************************
  * Timer Flag Register
  */
  final abstract class TFLG1  : Register!(0X11C  , Access.read_write32)
  {
    /************************************************************************************
    Timer Interrupt Flag
      0  #0  Timeout has not yet occurred.
      1  #1  Timeout has occurred.
    */
    alias TIF =   Bit!(1, Mutability.read_write);

  }
}
/****************************************************************************************
  * Timer/PWM Module
*/
final abstract class TPM0: Peripheral!(0x40038000)
{
  /**************************************************************************************
  * Status and Control
  */
  final abstract class SC  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Prescale Factor Selection
      000  #000  Divide by 1
      001  #001  Divide by 2
      010  #010  Divide by 4
      011  #011  Divide by 8
      100  #100  Divide by 16
      101  #101  Divide by 32
      110  #110  Divide by 64
      111  #111  Divide by 128
    */
    alias PS =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Clock Mode Selection
      00  #00  LPTPM counter is disabled
      01  #01  LPTPM counter increments on every LPTPM counter clock
      10  #10  LPTPM counter increments on rising edge of LPTPM_EXTCLK synchronized to the LPTPM counter clock
    */
    alias CMOD =   BitField!(5, 3, Mutability.read_write);

    /************************************************************************************
    Center-aligned PWM Select
      0  #0  LPTPM counter operates in up counting mode.
      1  #1  LPTPM counter operates in up-down counting mode.
    */
    alias CPWMS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Interrupt Enable
      0  #0  Disable TOF interrupts. Use software polling or DMA request.
      1  #1  Enable TOF interrupts. An interrupt is generated when TOF equals one.
    */
    alias TOIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    DMA Enable
      0  #0  Disables DMA transfers.
      1  #1  Enables DMA transfers.
    */
    alias DMA =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Counter
  */
  final abstract class CNT  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Counter value
    */
    alias COUNT =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Modulo
  */
  final abstract class MOD  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Modulo value
    */
    alias MOD =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C0SC  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C1SC  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C2SC  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C3SC  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C4SC  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C5SC  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C0V  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C1V  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C2V  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C3V  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C4V  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C5V  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Capture and Compare Status
  */
  final abstract class STATUS  : Register!(0x50  , Access.read_write32)
  {
    /************************************************************************************
    Channel 0 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH0F =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Channel 1 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH1F =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Channel 2 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH2F =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Channel 3 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH3F =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel 4 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH4F =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel 5 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH5F =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Configuration
  */
  final abstract class CONF  : Register!(0x84  , Access.read_write32)
  {
    /************************************************************************************
    Doze Enable
      0  #0  Internal LPTPM counter continues in Doze mode.
      1  #1  Internal LPTPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.
    */
    alias DOZEEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Debug Mode
      00  #00  LPTPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
      11  #11  LPTPM counter continues in debug mode.
    */
    alias DBGMODE =   BitField!(8, 6, Mutability.read_write);

    /************************************************************************************
    Global time base enable
      0  #0  All channels use the internally generated LPTPM counter as their timebase
      1  #1  All channels use an externally generated global timebase as their timebase
    */
    alias GTBEEN =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Counter Start on Trigger
      0  #0  LPTPM counter starts to increment immediately, once it is enabled.
      1  #1  LPTPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.
    */
    alias CSOT =   Bit!(17, Mutability.read_write);

    /************************************************************************************
    Counter Stop On Overflow
      0  #0  LPTPM counter continues incrementing or decrementing after overflow
      1  #1  LPTPM counter stops incrementing or decrementing after overflow.
    */
    alias CSOO =   Bit!(18, Mutability.read_write);

    /************************************************************************************
    Counter Reload On Trigger
      0  #0  Counter is not reloaded due to a rising edge on the selected input trigger
      1  #1  Counter is reloaded when a rising edge is detected on the selected input trigger
    */
    alias CROT =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    Trigger Select
    */
    alias TRGSEL =   BitField!(28, 24, Mutability.read_write);

  }
}
/****************************************************************************************
  * Timer/PWM Module
*/
final abstract class TPM1: Peripheral!(0x40039000)
{
  /**************************************************************************************
  * Status and Control
  */
  final abstract class SC  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Prescale Factor Selection
      000  #000  Divide by 1
      001  #001  Divide by 2
      010  #010  Divide by 4
      011  #011  Divide by 8
      100  #100  Divide by 16
      101  #101  Divide by 32
      110  #110  Divide by 64
      111  #111  Divide by 128
    */
    alias PS =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Clock Mode Selection
      00  #00  LPTPM counter is disabled
      01  #01  LPTPM counter increments on every LPTPM counter clock
      10  #10  LPTPM counter increments on rising edge of LPTPM_EXTCLK synchronized to the LPTPM counter clock
    */
    alias CMOD =   BitField!(5, 3, Mutability.read_write);

    /************************************************************************************
    Center-aligned PWM Select
      0  #0  LPTPM counter operates in up counting mode.
      1  #1  LPTPM counter operates in up-down counting mode.
    */
    alias CPWMS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Interrupt Enable
      0  #0  Disable TOF interrupts. Use software polling or DMA request.
      1  #1  Enable TOF interrupts. An interrupt is generated when TOF equals one.
    */
    alias TOIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    DMA Enable
      0  #0  Disables DMA transfers.
      1  #1  Enables DMA transfers.
    */
    alias DMA =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Counter
  */
  final abstract class CNT  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Counter value
    */
    alias COUNT =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Modulo
  */
  final abstract class MOD  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Modulo value
    */
    alias MOD =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C0SC  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C1SC  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C0V  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C1V  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Capture and Compare Status
  */
  final abstract class STATUS  : Register!(0x50  , Access.read_write32)
  {
    /************************************************************************************
    Channel 0 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH0F =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Channel 1 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH1F =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Channel 2 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH2F =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Channel 3 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH3F =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel 4 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH4F =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel 5 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH5F =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Configuration
  */
  final abstract class CONF  : Register!(0x84  , Access.read_write32)
  {
    /************************************************************************************
    Doze Enable
      0  #0  Internal LPTPM counter continues in Doze mode.
      1  #1  Internal LPTPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.
    */
    alias DOZEEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Debug Mode
      00  #00  LPTPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
      11  #11  LPTPM counter continues in debug mode.
    */
    alias DBGMODE =   BitField!(8, 6, Mutability.read_write);

    /************************************************************************************
    Global time base enable
      0  #0  All channels use the internally generated LPTPM counter as their timebase
      1  #1  All channels use an externally generated global timebase as their timebase
    */
    alias GTBEEN =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Counter Start on Trigger
      0  #0  LPTPM counter starts to increment immediately, once it is enabled.
      1  #1  LPTPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.
    */
    alias CSOT =   Bit!(17, Mutability.read_write);

    /************************************************************************************
    Counter Stop On Overflow
      0  #0  LPTPM counter continues incrementing or decrementing after overflow
      1  #1  LPTPM counter stops incrementing or decrementing after overflow.
    */
    alias CSOO =   Bit!(18, Mutability.read_write);

    /************************************************************************************
    Counter Reload On Trigger
      0  #0  Counter is not reloaded due to a rising edge on the selected input trigger
      1  #1  Counter is reloaded when a rising edge is detected on the selected input trigger
    */
    alias CROT =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    Trigger Select
    */
    alias TRGSEL =   BitField!(28, 24, Mutability.read_write);

  }
}
/****************************************************************************************
  * Timer/PWM Module
*/
final abstract class TPM2: Peripheral!(0x4003A000)
{
  /**************************************************************************************
  * Status and Control
  */
  final abstract class SC  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Prescale Factor Selection
      000  #000  Divide by 1
      001  #001  Divide by 2
      010  #010  Divide by 4
      011  #011  Divide by 8
      100  #100  Divide by 16
      101  #101  Divide by 32
      110  #110  Divide by 64
      111  #111  Divide by 128
    */
    alias PS =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Clock Mode Selection
      00  #00  LPTPM counter is disabled
      01  #01  LPTPM counter increments on every LPTPM counter clock
      10  #10  LPTPM counter increments on rising edge of LPTPM_EXTCLK synchronized to the LPTPM counter clock
    */
    alias CMOD =   BitField!(5, 3, Mutability.read_write);

    /************************************************************************************
    Center-aligned PWM Select
      0  #0  LPTPM counter operates in up counting mode.
      1  #1  LPTPM counter operates in up-down counting mode.
    */
    alias CPWMS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Interrupt Enable
      0  #0  Disable TOF interrupts. Use software polling or DMA request.
      1  #1  Enable TOF interrupts. An interrupt is generated when TOF equals one.
    */
    alias TOIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    DMA Enable
      0  #0  Disables DMA transfers.
      1  #1  Enables DMA transfers.
    */
    alias DMA =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Counter
  */
  final abstract class CNT  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Counter value
    */
    alias COUNT =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Modulo
  */
  final abstract class MOD  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Modulo value
    */
    alias MOD =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C0SC  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Status and Control
  */
  final abstract class C1SC  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    DMA Enable
      0  #0  Disable DMA transfers.
      1  #1  Enable DMA transfers.
    */
    alias DMA =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Edge or Level Select
    */
    alias ELSB =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSA =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel Mode Select
    */
    alias MSB =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Channel Interrupt Enable
      0  #0  Disable channel interrupts.
      1  #1  Enable channel interrupts.
    */
    alias CHIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Channel Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CHF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C0V  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Channel (n) Value
  */
  final abstract class C1V  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Channel Value
    */
    alias VAL =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Capture and Compare Status
  */
  final abstract class STATUS  : Register!(0x50  , Access.read_write32)
  {
    /************************************************************************************
    Channel 0 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH0F =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Channel 1 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH1F =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Channel 2 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH2F =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Channel 3 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH3F =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Channel 4 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH4F =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Channel 5 Flag
      0  #0  No channel event has occurred.
      1  #1  A channel event has occurred.
    */
    alias CH5F =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Timer Overflow Flag
      0  #0  LPTPM counter has not overflowed.
      1  #1  LPTPM counter has overflowed.
    */
    alias TOF =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * Configuration
  */
  final abstract class CONF  : Register!(0x84  , Access.read_write32)
  {
    /************************************************************************************
    Doze Enable
      0  #0  Internal LPTPM counter continues in Doze mode.
      1  #1  Internal LPTPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.
    */
    alias DOZEEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Debug Mode
      00  #00  LPTPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
      11  #11  LPTPM counter continues in debug mode.
    */
    alias DBGMODE =   BitField!(8, 6, Mutability.read_write);

    /************************************************************************************
    Global time base enable
      0  #0  All channels use the internally generated LPTPM counter as their timebase
      1  #1  All channels use an externally generated global timebase as their timebase
    */
    alias GTBEEN =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Counter Start on Trigger
      0  #0  LPTPM counter starts to increment immediately, once it is enabled.
      1  #1  LPTPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.
    */
    alias CSOT =   Bit!(17, Mutability.read_write);

    /************************************************************************************
    Counter Stop On Overflow
      0  #0  LPTPM counter continues incrementing or decrementing after overflow
      1  #1  LPTPM counter stops incrementing or decrementing after overflow.
    */
    alias CSOO =   Bit!(18, Mutability.read_write);

    /************************************************************************************
    Counter Reload On Trigger
      0  #0  Counter is not reloaded due to a rising edge on the selected input trigger
      1  #1  Counter is reloaded when a rising edge is detected on the selected input trigger
    */
    alias CROT =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    Trigger Select
    */
    alias TRGSEL =   BitField!(28, 24, Mutability.read_write);

  }
}
/****************************************************************************************
  * Analog-to-Digital Converter
*/
final abstract class ADC0: Peripheral!(0x4003B000)
{
  /**************************************************************************************
  * ADC Status and Control Registers 1
  */
  final abstract class SC1A  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Input channel select
      00000  #00000  When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
      00001  #00001  When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
      00010  #00010  When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
      00011  #00011  When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
      00100  #00100  When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
      00101  #00101  When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
      00110  #00110  When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
      00111  #00111  When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
      01000  #01000  When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
      01001  #01001  When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
      01010  #01010  When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
      01011  #01011  When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
      01100  #01100  When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
      01101  #01101  When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
      01110  #01110  When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
      01111  #01111  When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
      10000  #10000  When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
      10001  #10001  When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
      10010  #10010  When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
      10011  #10011  When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
      10100  #10100  When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
      10101  #10101  When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
      10110  #10110  When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
      10111  #10111  When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
      11010  #11010  When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
      11011  #11011  When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
      11101  #11101  When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
      11110  #11110  When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
      11111  #11111  Module is disabled.
    */
    alias ADCH =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Differential Mode Enable
      0  #0  Single-ended conversions and input channels are selected.
      1  #1  Differential conversions and input channels are selected.
    */
    alias DIFF =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Interrupt Enable
      0  #0  Conversion complete interrupt is disabled.
      1  #1  Conversion complete interrupt is enabled.
    */
    alias AIEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Conversion Complete Flag
      0  #0  Conversion is not completed.
      1  #1  Conversion is completed.
    */
    alias COCO =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * ADC Status and Control Registers 1
  */
  final abstract class SC1B  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Input channel select
      00000  #00000  When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
      00001  #00001  When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
      00010  #00010  When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
      00011  #00011  When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
      00100  #00100  When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
      00101  #00101  When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
      00110  #00110  When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
      00111  #00111  When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
      01000  #01000  When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
      01001  #01001  When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
      01010  #01010  When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
      01011  #01011  When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
      01100  #01100  When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
      01101  #01101  When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
      01110  #01110  When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
      01111  #01111  When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
      10000  #10000  When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
      10001  #10001  When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
      10010  #10010  When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
      10011  #10011  When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
      10100  #10100  When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
      10101  #10101  When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
      10110  #10110  When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
      10111  #10111  When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
      11010  #11010  When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
      11011  #11011  When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
      11101  #11101  When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
      11110  #11110  When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
      11111  #11111  Module is disabled.
    */
    alias ADCH =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Differential Mode Enable
      0  #0  Single-ended conversions and input channels are selected.
      1  #1  Differential conversions and input channels are selected.
    */
    alias DIFF =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Interrupt Enable
      0  #0  Conversion complete interrupt is disabled.
      1  #1  Conversion complete interrupt is enabled.
    */
    alias AIEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Conversion Complete Flag
      0  #0  Conversion is not completed.
      1  #1  Conversion is completed.
    */
    alias COCO =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * ADC Configuration Register 1
  */
  final abstract class CFG1  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Input Clock Select
      00  #00  Bus clock
      01  #01  (Bus clock)/2
      10  #10  Alternate clock (ALTCLK)
      11  #11  Asynchronous clock (ADACK)
    */
    alias ADICLK =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Conversion mode selection
      00  #00  When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2's complement output.
      01  #01  When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2's complement output.
      10  #10  When DIFF=0:It is single-ended 10-bit conversion ; when DIFF=1, it is differential 11-bit conversion with 2's complement output.
      11  #11  When DIFF=0:It is single-ended 16-bit conversion; when DIFF=1, it is differential 16-bit conversion with 2's complement output.
    */
    alias MODE =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Sample time configuration
      0  #0  Short sample time.
      1  #1  Long sample time.
    */
    alias ADLSMP =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Clock Divide Select
      00  #00  The divide ratio is 1 and the clock rate is input clock.
      01  #01  The divide ratio is 2 and the clock rate is (input clock)/2.
      10  #10  The divide ratio is 4 and the clock rate is (input clock)/4.
      11  #11  The divide ratio is 8 and the clock rate is (input clock)/8.
    */
    alias ADIV =   BitField!(7, 5, Mutability.read_write);

    /************************************************************************************
    Low-Power Configuration
      0  #0  Normal power configuration.
      1  #1  Low-power configuration. The power is reduced at the expense of maximum clock speed.
    */
    alias ADLPC =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Configuration Register 2
  */
  final abstract class CFG2  : Register!(0xC  , Access.read_write32)
  {
    /************************************************************************************
    Long Sample Time Select
      00  #00  Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
      01  #01  12 extra ADCK cycles; 16 ADCK cycles total sample time.
      10  #10  6 extra ADCK cycles; 10 ADCK cycles total sample time.
      11  #11  2 extra ADCK cycles; 6 ADCK cycles total sample time.
    */
    alias ADLSTS =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    High-Speed Configuration
      0  #0  Normal conversion sequence selected.
      1  #1  High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.
    */
    alias ADHSC =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Asynchronous Clock Output Enable
      0  #0  Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
      1  #1  Asynchronous clock and clock output is enabled regardless of the state of the ADC.
    */
    alias ADACKEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    ADC Mux Select
      0  #0  ADxxa channels are selected.
      1  #1  ADxxb channels are selected.
    */
    alias MUXSEL =   Bit!(5, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Data Result Register
  */
  final abstract class RA  : Register!(0X10  , Access.read_only32)
  {
    /************************************************************************************
    Data result
    */
    alias D =   BitField!(16, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * ADC Data Result Register
  */
  final abstract class RB  : Register!(0X14  , Access.read_only32)
  {
    /************************************************************************************
    Data result
    */
    alias D =   BitField!(16, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Compare Value Registers
  */
  final abstract class CV1  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Compare Value.
    */
    alias CV =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Compare Value Registers
  */
  final abstract class CV2  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Compare Value.
    */
    alias CV =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Status and Control Register 2
  */
  final abstract class SC2  : Register!(0x20  , Access.read_write32)
  {
    /************************************************************************************
    Voltage Reference Selection
      00  #00  Default voltage reference pin pair, that is, external pins VREFH and VREFL
      01  #01  Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU
    */
    alias REFSEL =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    DMA Enable
      0  #0  DMA is disabled.
      1  #1  DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n[COCO] flags is asserted.
    */
    alias DMAEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Compare Function Range Enable
      0  #0  Range function disabled. Only CV1 is compared.
      1  #1  Range function enabled. Both CV1 and CV2 are compared.
    */
    alias ACREN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Compare Function Greater Than Enable
      0  #0  Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
      1  #1  Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.
    */
    alias ACFGT =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Compare Function Enable
      0  #0  Compare function disabled.
      1  #1  Compare function enabled.
    */
    alias ACFE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Conversion Trigger Select
      0  #0  Software trigger selected.
      1  #1  Hardware trigger selected.
    */
    alias ADTRG =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Conversion Active
      0  #0  Conversion not in progress.
      1  #1  Conversion in progress.
    */
    alias ADACT =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * Status and Control Register 3
  */
  final abstract class SC3  : Register!(0x24  , Access.read_write32)
  {
    /************************************************************************************
    Hardware Average Select
      00  #00  4 samples averaged.
      01  #01  8 samples averaged.
      10  #10  16 samples averaged.
      11  #11  32 samples averaged.
    */
    alias AVGS =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Hardware Average Enable
      0  #0  Hardware average function disabled.
      1  #1  Hardware average function enabled.
    */
    alias AVGE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Continuous Conversion Enable
      0  #0  One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
      1  #1  Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
    */
    alias ADCO =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Calibration Failed Flag
      0  #0  Calibration completed normally.
      1  #1  Calibration failed. ADC accuracy specifications are not guaranteed.
    */
    alias CALF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Calibration
    */
    alias CAL =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Offset Correction Register
  */
  final abstract class OFS  : Register!(0x28  , Access.read_write32)
  {
    /************************************************************************************
    Offset Error Correction Value
    */
    alias OFS =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side Gain Register
  */
  final abstract class PG  : Register!(0x2C  , Access.read_write32)
  {
    /************************************************************************************
    Plus-Side Gain
    */
    alias PG =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side Gain Register
  */
  final abstract class MG  : Register!(0x30  , Access.read_write32)
  {
    /************************************************************************************
    Minus-Side Gain
    */
    alias MG =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLPD  : Register!(0x34  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLPD =   BitField!(6, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLPS  : Register!(0x38  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLPS =   BitField!(6, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLP4  : Register!(0x3C  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLP4 =   BitField!(10, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLP3  : Register!(0x40  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLP3 =   BitField!(9, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLP2  : Register!(0x44  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLP2 =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLP1  : Register!(0x48  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLP1 =   BitField!(7, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Plus-Side General Calibration Value Register
  */
  final abstract class CLP0  : Register!(0x4C  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLP0 =   BitField!(6, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLMD  : Register!(0x54  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLMD =   BitField!(6, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLMS  : Register!(0x58  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLMS =   BitField!(6, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLM4  : Register!(0x5C  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLM4 =   BitField!(10, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLM3  : Register!(0x60  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLM3 =   BitField!(9, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLM2  : Register!(0x64  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLM2 =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLM1  : Register!(0x68  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLM1 =   BitField!(7, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * ADC Minus-Side General Calibration Value Register
  */
  final abstract class CLM0  : Register!(0x6C  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias CLM0 =   BitField!(6, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Secure Real Time Clock
*/
final abstract class RTC: Peripheral!(0x4003D000)
{
  /**************************************************************************************
  * RTC Time Seconds Register
  */
  final abstract class TSR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Time Seconds Register
    */
    alias TSR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Time Prescaler Register
  */
  final abstract class TPR  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Time Prescaler Register
    */
    alias TPR =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Time Alarm Register
  */
  final abstract class TAR  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Time Alarm Register
    */
    alias TAR =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Time Compensation Register
  */
  final abstract class TCR  : Register!(0xC  , Access.read_write32)
  {
    /************************************************************************************
    Time Compensation Register
      10000000  #10000000  Time Prescaler Register overflows every 32896 clock cycles.
      11111111  #11111111  Time Prescaler Register overflows every 32769 clock cycles.
      0  #0  Time Prescaler Register overflows every 32768 clock cycles.
      1  #1  Time Prescaler Register overflows every 32767 clock cycles.
      1111111  #1111111  Time Prescaler Register overflows every 32641 clock cycles.
    */
    alias TCR =   BitField!(8, 0, Mutability.read_write);

    /************************************************************************************
    Compensation Interval Register
    */
    alias CIR =   BitField!(16, 8, Mutability.read_write);

    /************************************************************************************
    Time Compensation Value
    */
    alias TCV =   BitField!(24, 16, Mutability.read_only);

    /************************************************************************************
    Compensation Interval Counter
    */
    alias CIC =   BitField!(32, 24, Mutability.read_only);

  }
  /**************************************************************************************
  * RTC Control Register
  */
  final abstract class CR  : Register!(0x10  , Access.read_write32)
  {
    /************************************************************************************
    Software Reset
      0  #0  No effect.
      1  #1  Resets all RTC registers except for the SWR bit . The SWR bit is cleared by POR and by software explicitly clearing it.
    */
    alias SWR =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable
      0  #0  Wakeup pin is disabled.
      1  #1  Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt asserts or the wakeup pin is turned on.
    */
    alias WPE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Supervisor Access
      0  #0  Non-supervisor mode write accesses are not supported and generate a bus error.
      1  #1  Non-supervisor mode write accesses are supported.
    */
    alias SUP =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Update Mode
      0  #0  Registers cannot be written when locked.
      1  #1  Registers can be written when locked under limited conditions.
    */
    alias UM =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Oscillator Enable
      0  #0  32.768 kHz oscillator is disabled.
      1  #1  32.768 kHz oscillator is enabled. After setting this bit, wait the oscillator startup time before enabling the time counter to allow the 32.768 kHz clock time to stabilize.
    */
    alias OSCE =   Bit!(9, Mutability.read_write);

    /************************************************************************************
    Clock Output
      0  #0  The 32 kHz clock is output to other peripherals.
      1  #1  The 32 kHz clock is not output to other peripherals.
    */
    alias CLKO =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Oscillator 16pF Load Configure
      0  #0  Disable the load.
      1  #1  Enable the additional load.
    */
    alias SC16P =   Bit!(11, Mutability.read_write);

    /************************************************************************************
    Oscillator 8pF Load Configure
      0  #0  Disable the load.
      1  #1  Enable the additional load.
    */
    alias SC8P =   Bit!(12, Mutability.read_write);

    /************************************************************************************
    Oscillator 4pF Load Configure
      0  #0  Disable the load.
      1  #1  Enable the additional load.
    */
    alias SC4P =   Bit!(13, Mutability.read_write);

    /************************************************************************************
    Oscillator 2pF Load Configure
      0  #0  Disable the load.
      1  #1  Enable the additional load.
    */
    alias SC2P =   Bit!(14, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Status Register
  */
  final abstract class SR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Time Invalid Flag
      0  #0  Time is valid.
      1  #1  Time is invalid and time counter is read as zero.
    */
    alias TIF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Time Overflow Flag
      0  #0  Time overflow has not occurred.
      1  #1  Time overflow has occurred and time counter is read as zero.
    */
    alias TOF =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Time Alarm Flag
      0  #0  Time alarm has not occurred.
      1  #1  Time alarm has occurred.
    */
    alias TAF =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Time Counter Enable
      0  #0  Time counter is disabled.
      1  #1  Time counter is enabled.
    */
    alias TCE =   Bit!(5, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Lock Register
  */
  final abstract class LR  : Register!(0x18  , Access.read_write32)
  {
    /************************************************************************************
    Time Compensation Lock
      0  #0  Time Compensation Register is locked and writes are ignored.
      1  #1  Time Compensation Register is not locked and writes complete as normal.
    */
    alias TCL =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Control Register Lock
      0  #0  Control Register is locked and writes are ignored.
      1  #1  Control Register is not locked and writes complete as normal.
    */
    alias CRL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Status Register Lock
      0  #0  Status Register is locked and writes are ignored.
      1  #1  Status Register is not locked and writes complete as normal.
    */
    alias SRL =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Lock Register Lock
      0  #0  Lock Register is locked and writes are ignored.
      1  #1  Lock Register is not locked and writes complete as normal.
    */
    alias LRL =   Bit!(7, Mutability.read_write);

  }
  /**************************************************************************************
  * RTC Interrupt Enable Register
  */
  final abstract class IER  : Register!(0x1C  , Access.read_write32)
  {
    /************************************************************************************
    Time Invalid Interrupt Enable
      0  #0  Time invalid flag does not generate an interrupt.
      1  #1  Time invalid flag does generate an interrupt.
    */
    alias TIIE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Time Overflow Interrupt Enable
      0  #0  Time overflow flag does not generate an interrupt.
      1  #1  Time overflow flag does generate an interrupt.
    */
    alias TOIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Time Alarm Interrupt Enable
      0  #0  Time alarm flag does not generate an interrupt.
      1  #1  Time alarm flag does generate an interrupt.
    */
    alias TAIE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Time Seconds Interrupt Enable
      0  #0  Seconds interrupt is disabled.
      1  #1  Seconds interrupt is enabled.
    */
    alias TSIE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin On
      0  #0  No effect.
      1  #1  If the wakeup pin is enabled, then the wakeup pin will assert.
    */
    alias WPON =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * 12-Bit Digital-to-Analog Converter
*/
final abstract class DAC0: Peripheral!(0x4003F000)
{
  /**************************************************************************************
  * DAC Data Low Register
  */
  final abstract class DAT0L  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias DATA0 =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Data Low Register
  */
  final abstract class DAT1L  : Register!(0X2  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias DATA0 =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Data High Register
  */
  final abstract class DAT0H  : Register!(0X1  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias DATA1 =   BitField!(4, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Data High Register
  */
  final abstract class DAT1H  : Register!(0X3  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias DATA1 =   BitField!(4, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Status Register
  */
  final abstract class SR  : Register!(0x20  , Access.read_write8)
  {
    /************************************************************************************
    DAC Buffer Read Pointer Bottom Position Flag
      0  #0  The DAC buffer read pointer is not equal to C2[DACBFUP].
      1  #1  The DAC buffer read pointer is equal to C2[DACBFUP].
    */
    alias DACBFRPBF =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    DAC Buffer Read Pointer Top Position Flag
      0  #0  The DAC buffer read pointer is not zero.
      1  #1  The DAC buffer read pointer is zero.
    */
    alias DACBFRPTF =   Bit!(2, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Control Register
  */
  final abstract class C0  : Register!(0x21  , Access.read_write8)
  {
    /************************************************************************************
    DAC Buffer Read Pointer Bottom Flag Interrupt Enable
      0  #0  The DAC buffer read pointer bottom flag interrupt is disabled.
      1  #1  The DAC buffer read pointer bottom flag interrupt is enabled.
    */
    alias DACBBIEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    DAC Buffer Read Pointer Top Flag Interrupt Enable
      0  #0  The DAC buffer read pointer top flag interrupt is disabled.
      1  #1  The DAC buffer read pointer top flag interrupt is enabled.
    */
    alias DACBTIEN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    DAC Low Power Control
      0  #0  High-Power mode
      1  #1  Low-Power mode
    */
    alias LPEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    DAC Software Trigger
      0  #0  The DAC soft trigger is not valid.
      1  #1  The DAC soft trigger is valid.
    */
    alias DACSWTRG =   Bit!(5, Mutability.write_only);

    /************************************************************************************
    DAC Trigger Select
      0  #0  The DAC hardware trigger is selected.
      1  #1  The DAC software trigger is selected.
    */
    alias DACTRGSEL =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    DAC Reference Select
      0  #0  The DAC selects DACREF_1 as the reference voltage.
      1  #1  The DAC selects DACREF_2 as the reference voltage.
    */
    alias DACRFS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DAC Enable
      0  #0  The DAC system is disabled.
      1  #1  The DAC system is enabled.
    */
    alias DACEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Control Register 1
  */
  final abstract class C1  : Register!(0x22  , Access.read_write8)
  {
    /************************************************************************************
    DAC Buffer Enable
      0  #0  Buffer read pointer is disabled. The converted data is always the first word of the buffer.
      1  #1  Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer.
    */
    alias DACBFEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    DAC Buffer Work Mode Select
      0  #0  Normal mode
      1  #1  One-Time Scan mode
    */
    alias DACBFMD =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    DMA Enable Select
      0  #0  DMA is disabled.
      1  #1  DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time.
    */
    alias DMAEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Control Register 2
  */
  final abstract class C2  : Register!(0x23  , Access.read_write8)
  {
    /************************************************************************************
    DAC Buffer Upper Limit
    */
    alias DACBFUP =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    DAC Buffer Read Pointer
    */
    alias DACBFRP =   Bit!(5, Mutability.read_write);

  }
}
/****************************************************************************************
  * Low Power Timer
*/
final abstract class LPTMR0: Peripheral!(0x40040000)
{
  /**************************************************************************************
  * Low Power Timer Control Status Register
  */
  final abstract class CSR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Timer Enable
      0  #0  LPTMR is disabled and internal logic is reset.
      1  #1  LPTMR is enabled.
    */
    alias TEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Timer Mode Select
      0  #0  Time Counter mode.
      1  #1  Pulse Counter mode.
    */
    alias TMS =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Timer Free-Running Counter
      0  #0  CNR is reset whenever TCF is set.
      1  #1  CNR is reset on overflow.
    */
    alias TFC =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Timer Pin Polarity
      0  #0  Pulse Counter input source is active-high, and the CNR will increment on the rising-edge.
      1  #1  Pulse Counter input source is active-low, and the CNR will increment on the falling-edge.
    */
    alias TPP =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Timer Pin Select
      00  #00  Pulse counter input 0 is selected.
      01  #01  Pulse counter input 1 is selected.
      10  #10  Pulse counter input 2 is selected.
      11  #11  Pulse counter input 3 is selected.
    */
    alias TPS =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Timer Interrupt Enable
      0  #0  Timer interrupt disabled.
      1  #1  Timer interrupt enabled.
    */
    alias TIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Timer Compare Flag
      0  #0  The value of CNR is not equal to CMR and increments.
      1  #1  The value of CNR is equal to CMR and increments.
    */
    alias TCF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Low Power Timer Prescale Register
  */
  final abstract class PSR  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Prescaler Clock Select
      00  #00  Prescaler/glitch filter clock 0 selected.
      01  #01  Prescaler/glitch filter clock 1 selected.
      10  #10  Prescaler/glitch filter clock 2 selected.
      11  #11  Prescaler/glitch filter clock 3 selected.
    */
    alias PCS =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Prescaler Bypass
      0  #0  Prescaler/glitch filter is enabled.
      1  #1  Prescaler/glitch filter is bypassed.
    */
    alias PBYP =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Prescale Value
      0000  #0000  Prescaler divides the prescaler clock by 2; glitch filter does not support this configuration.
      0001  #0001  Prescaler divides the prescaler clock by 4; glitch filter recognizes change on input pin after 2 rising clock edges.
      0010  #0010  Prescaler divides the prescaler clock by 8; glitch filter recognizes change on input pin after 4 rising clock edges.
      0011  #0011  Prescaler divides the prescaler clock by 16; glitch filter recognizes change on input pin after 8 rising clock edges.
      0100  #0100  Prescaler divides the prescaler clock by 32; glitch filter recognizes change on input pin after 16 rising clock edges.
      0101  #0101  Prescaler divides the prescaler clock by 64; glitch filter recognizes change on input pin after 32 rising clock edges.
      0110  #0110  Prescaler divides the prescaler clock by 128; glitch filter recognizes change on input pin after 64 rising clock edges.
      0111  #0111  Prescaler divides the prescaler clock by 256; glitch filter recognizes change on input pin after 128 rising clock edges.
      1000  #1000  Prescaler divides the prescaler clock by 512; glitch filter recognizes change on input pin after 256 rising clock edges.
      1001  #1001  Prescaler divides the prescaler clock by 1024; glitch filter recognizes change on input pin after 512 rising clock edges.
      1010  #1010  Prescaler divides the prescaler clock by 2048; glitch filter recognizes change on input pin after 1024 rising clock edges.
      1011  #1011  Prescaler divides the prescaler clock by 4096; glitch filter recognizes change on input pin after 2048 rising clock edges.
      1100  #1100  Prescaler divides the prescaler clock by 8192; glitch filter recognizes change on input pin after 4096 rising clock edges.
      1101  #1101  Prescaler divides the prescaler clock by 16,384; glitch filter recognizes change on input pin after 8192 rising clock edges.
      1110  #1110  Prescaler divides the prescaler clock by 32,768; glitch filter recognizes change on input pin after 16,384 rising clock edges.
      1111  #1111  Prescaler divides the prescaler clock by 65,536; glitch filter recognizes change on input pin after 32,768 rising clock edges.
    */
    alias PRESCALE =   BitField!(7, 3, Mutability.read_write);

  }
  /**************************************************************************************
  * Low Power Timer Compare Register
  */
  final abstract class CMR  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    Compare Value
    */
    alias COMPARE =   BitField!(16, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Low Power Timer Counter Register
  */
  final abstract class CNR  : Register!(0xC  , Access.read_write32)
  {
    /************************************************************************************
    Counter Value
    */
    alias COUNTER =   BitField!(16, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Touch sense input
*/
final abstract class TSI0: Peripheral!(0x40045000)
{
  /**************************************************************************************
  * TSI General Control and Status Register
  */
  final abstract class GENCS  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    CURSW
      0  #0  The current source pair are not swapped.
      1  #1  The current source pair are swapped.
    */
    alias CURSW =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    End of Scan Flag
      0  #0  Scan not complete.
      1  #1  Scan complete.
    */
    alias EOSF =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Scan In Progress Status
      0  #0  No scan in progress.
      1  #1  Scan in progress.
    */
    alias SCNIP =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Scan Trigger Mode
      0  #0  Software trigger scan.
      1  #1  Hardware trigger scan.
    */
    alias STM =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    TSI STOP Enable
      0  #0  TSI is disabled when MCU goes into low power mode.
      1  #1  Allows TSI to continue running in all low power modes.
    */
    alias STPE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Touch Sensing Input Interrupt Enable
      0  #0  TSI interrupt is disabled.
      1  #1  TSI interrupt is enabled.
    */
    alias TSIIEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Touch Sensing Input Module Enable
      0  #0  TSI module disabled.
      1  #1  TSI module enabled.
    */
    alias TSIEN =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    NSCN
      00000  #00000  Once per electrode
      00001  #00001  Twice per electrode
      00010  #00010  3 times per electrode
      00011  #00011  4 times per electrode
      00100  #00100  5 times per electrode
      00101  #00101  6 times per electrode
      00110  #00110  7 times per electrode
      00111  #00111  8 times per electrode
      01000  #01000  9 times per electrode
      01001  #01001  10 times per electrode
      01010  #01010  11 times per electrode
      01011  #01011  12 times per electrode
      01100  #01100  13 times per electrode
      01101  #01101  14 times per electrode
      01110  #01110  15 times per electrode
      01111  #01111  16 times per electrode
      10000  #10000  17 times per electrode
      10001  #10001  18 times per electrode
      10010  #10010  19 times per electrode
      10011  #10011  20 times per electrode
      10100  #10100  21 times per electrode
      10101  #10101  22 times per electrode
      10110  #10110  23 times per electrode
      10111  #10111  24 times per electrode
      11000  #11000  25 times per electrode
      11001  #11001  26 times per electrode
      11010  #11010  27 times per electrode
      11011  #11011  28 times per electrode
      11100  #11100  29 times per electrode
      11101  #11101  30 times per electrode
      11110  #11110  31 times per electrode
      11111  #11111  32 times per electrode
    */
    alias NSCN =   BitField!(13, 8, Mutability.read_write);

    /************************************************************************************
    PS
      000  #000  Electrode Oscillator Frequency divided by 1
      001  #001  Electrode Oscillator Frequency divided by 2
      010  #010  Electrode Oscillator Frequency divided by 4
      011  #011  Electrode Oscillator Frequency divided by 8
      100  #100  Electrode Oscillator Frequency divided by 16
      101  #101  Electrode Oscillator Frequency divided by 32
      110  #110  Electrode Oscillator Frequency divided by 64
      111  #111  Electrode Oscillator Frequency divided by 128
    */
    alias PS =   BitField!(16, 13, Mutability.read_write);

    /************************************************************************************
    EXTCHRG
      000  #000  500 nA.
      001  #001  1 uA.
      010  #010  2 uA.
      011  #011  4 uA.
      100  #100  8 uA.
      101  #101  16 uA.
      110  #110  32 uA.
      111  #111  64 uA.
    */
    alias EXTCHRG =   BitField!(19, 16, Mutability.read_write);

    /************************************************************************************
    DVOLT
      00  #00  DV = 1.03 V; VP = 1.33 V; Vm = 0.30 V.
      01  #01  DV = 0.73 V; VP = 1.18 V; Vm = 0.45 V.
      10  #10  DV = 0.43 V; VP = 1.03 V; Vm = 0.60 V.
      11  #11  DV = 0.29 V; VP = 0.95 V; Vm = 0.67 V.
    */
    alias DVOLT =   BitField!(21, 19, Mutability.read_write);

    /************************************************************************************
    REFCHRG
      000  #000  500 nA.
      001  #001  1 uA.
      010  #010  2 uA.
      011  #011  4 uA.
      100  #100  8 uA.
      101  #101  16 uA.
      110  #110  32 uA.
      111  #111  64 uA.
    */
    alias REFCHRG =   BitField!(24, 21, Mutability.read_write);

    /************************************************************************************
    TSI analog modes setup and status bits.
      0000  #0000  Set TSI in capacitive sensing(non-noise detection) mode.
      0100  #0100  Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is disabled.
      1000  #1000  Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is enabled to work in higher frequencies operations.
      1100  #1100  Set TSI analog to work in automatic noise detection mode.
    */
    alias MODE =   BitField!(28, 24, Mutability.read_write);

    /************************************************************************************
    End-of-scan or Out-of-Range Interrupt Selection
      0  #0  Out-of-range interrupt is allowed.
      1  #1  End-of-scan interrupt is allowed.
    */
    alias ESOR =   Bit!(29, Mutability.read_write);

    /************************************************************************************
    Out of Range Flag.
    */
    alias OUTRGF =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * TSI DATA Register
  */
  final abstract class DATA  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    TSI Conversion Counter Value
    */
    alias TSICNT =   BitField!(16, 0, Mutability.read_only);

    /************************************************************************************
    Software Trigger Start
      0  #0  No effect.
      1  #1  Start a scan to determine which channel is specified by TSI_DATA[TSICH].
    */
    alias SWTS =   Bit!(23, Mutability.write_only);

    /************************************************************************************
    DMA Transfer Enabled
      0  #0  Interrupt is selected when the interrupt enable bit is set and the corresponding TSI events assert.
      1  #1  DMA transfer request is selected when the interrupt enable bit is set and the corresponding TSI events assert.
    */
    alias DMAEN =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    TSICH
      0000  #0000  Channel 0.
      0001  #0001  Channel 1.
      0010  #0010  Channel 2.
      0011  #0011  Channel 3.
      0100  #0100  Channel 4.
      0101  #0101  Channel 5.
      0110  #0110  Channel 6.
      0111  #0111  Channel 7.
      1000  #1000  Channel 8.
      1001  #1001  Channel 9.
      1010  #1010  Channel 10.
      1011  #1011  Channel 11.
      1100  #1100  Channel 12.
      1101  #1101  Channel 13.
      1110  #1110  Channel 14.
      1111  #1111  Channel 15.
    */
    alias TSICH =   BitField!(32, 28, Mutability.read_write);

  }
  /**************************************************************************************
  * TSI Threshold Register
  */
  final abstract class TSHD  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    TSI Wakeup Channel Low-threshold
    */
    alias THRESL =   BitField!(16, 0, Mutability.read_write);

    /************************************************************************************
    TSI Wakeup Channel High-threshold
    */
    alias THRESH =   BitField!(32, 16, Mutability.read_write);

  }
}
/****************************************************************************************
  * System Integration Module
*/
final abstract class SIM: Peripheral!(0x40047000)
{
  /**************************************************************************************
  * System Options Register 1
  */
  final abstract class SOPT1  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    32K oscillator clock select
      00  #00  System oscillator (OSC32KCLK)
      10  #10  RTC_CLKIN
      11  #11  LPO 1kHz
    */
    alias OSC32KSEL =   BitField!(20, 18, Mutability.read_write);

    /************************************************************************************
    USB voltage regulator in standby mode during VLPR and VLPW modes
      0  #0  USB voltage regulator not in standby during VLPR and VLPW modes.
      1  #1  USB voltage regulator in standby during VLPR and VLPW modes.
    */
    alias USBVSTBY =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
      0  #0  USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS modes.
      1  #1  USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
    */
    alias USBSSTBY =   Bit!(31, Mutability.read_write);

    /************************************************************************************
    USB voltage regulator enable
      0  #0  USB voltage regulator is disabled.
      1  #1  USB voltage regulator is enabled.
    */
    alias USBREGEN =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * SOPT1 Configuration Register
  */
  final abstract class SOPT1CFG  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    USB voltage regulator enable write enable
      0  #0  SOPT1 USBREGEN cannot be written.
      1  #1  SOPT1 USBREGEN can be written.
    */
    alias URWE =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    USB voltage regulator VLP standby write enable
      0  #0  SOPT1 USBVSTB cannot be written.
      1  #1  SOPT1 USBVSTB can be written.
    */
    alias UVSWE =   Bit!(26, Mutability.read_write);

    /************************************************************************************
    USB voltage regulator stop standby write enable
      0  #0  SOPT1 USBSSTB cannot be written.
      1  #1  SOPT1 USBSSTB can be written.
    */
    alias USSWE =   Bit!(27, Mutability.read_write);

  }
  /**************************************************************************************
  * System Options Register 2
  */
  final abstract class SOPT2  : Register!(0x1004  , Access.read_write32)
  {
    /************************************************************************************
    RTC clock out select
      0  #0  RTC 1 Hz clock is output on the RTC_CLKOUT pin.
      1  #1  OSCERCLK clock is output on the RTC_CLKOUT pin.
    */
    alias RTCCLKOUTSEL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    CLKOUT select
      010  #010  Bus clock
      011  #011  LPO clock (1 kHz)
      100  #100  MCGIRCLK
      110  #110  OSCERCLK
    */
    alias CLKOUTSEL =   BitField!(8, 5, Mutability.read_write);

    /************************************************************************************
    PLL/FLL clock select
      0  #0  MCGFLLCLK clock
      1  #1  MCGPLLCLK clock with fixed divide by two
    */
    alias PLLFLLSEL =   Bit!(17, Mutability.read_write);

    /************************************************************************************
    USB clock source select
      0  #0  External bypass clock (USB_CLKIN).
      1  #1  MCGPLLCLK/2 or MCGFLLCLK clock
    */
    alias USBSRC =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    TPM clock source select
      00  #00  Clock disabled
      01  #01  MCGFLLCLK clock or MCGPLLCLK/2
      10  #10  OSCERCLK clock
      11  #11  MCGIRCLK clock
    */
    alias TPMSRC =   BitField!(26, 24, Mutability.read_write);

    /************************************************************************************
    UART0 clock source select
      00  #00  Clock disabled
      01  #01  MCGFLLCLK clock or MCGPLLCLK/2 clock
      10  #10  OSCERCLK clock
      11  #11  MCGIRCLK clock
    */
    alias UART0SRC =   BitField!(28, 26, Mutability.read_write);

  }
  /**************************************************************************************
  * System Options Register 4
  */
  final abstract class SOPT4  : Register!(0x100C  , Access.read_write32)
  {
    /************************************************************************************
    TPM1 channel 0 input capture source select
      0  #0  TPM1_CH0 signal
      1  #1  CMP0 output
    */
    alias TPM1CH0SRC =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    TPM2 channel 0 input capture source select
      0  #0  TPM2_CH0 signal
      1  #1  CMP0 output
    */
    alias TPM2CH0SRC =   Bit!(21, Mutability.read_write);

    /************************************************************************************
    TPM0 External Clock Pin Select
      0  #0  TPM0 external clock driven by TPM_CLKIN0 pin.
      1  #1  TPM0 external clock driven by TPM_CLKIN1 pin.
    */
    alias TPM0CLKSEL =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    TPM1 External Clock Pin Select
      0  #0  TPM1 external clock driven by TPM_CLKIN0 pin.
      1  #1  TPM1 external clock driven by TPM_CLKIN1 pin.
    */
    alias TPM1CLKSEL =   Bit!(26, Mutability.read_write);

    /************************************************************************************
    TPM2 External Clock Pin Select
      0  #0  TPM2 external clock driven by TPM_CLKIN0 pin.
      1  #1  TPM2 external clock driven by TPM_CLKIN1 pin.
    */
    alias TPM2CLKSEL =   Bit!(27, Mutability.read_write);

  }
  /**************************************************************************************
  * System Options Register 5
  */
  final abstract class SOPT5  : Register!(0x1010  , Access.read_write32)
  {
    /************************************************************************************
    UART0 transmit data source select
      00  #00  UART0_TX pin
      01  #01  UART0_TX pin modulated with TPM1 channel 0 output
      10  #10  UART0_TX pin modulated with TPM2 channel 0 output
    */
    alias UART0TXSRC =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    UART0 receive data source select
      0  #0  UART0_RX pin
      1  #1  CMP0 output
    */
    alias UART0RXSRC =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    UART1 transmit data source select
      00  #00  UART1_TX pin
      01  #01  UART1_TX pin modulated with TPM1 channel 0 output
      10  #10  UART1_TX pin modulated with TPM2 channel 0 output
    */
    alias UART1TXSRC =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    UART1 receive data source select
      0  #0  UART1_RX pin
      1  #1  CMP0 output
    */
    alias UART1RXSRC =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    UART0 Open Drain Enable
      0  #0  Open drain is disabled on UART0
      1  #1  Open drain is enabled on UART0
    */
    alias UART0ODE =   Bit!(17, Mutability.read_write);

    /************************************************************************************
    UART1 Open Drain Enable
      0  #0  Open drain is disabled on UART1
      1  #1  Open drain is enabled on UART1
    */
    alias UART1ODE =   Bit!(18, Mutability.read_write);

    /************************************************************************************
    UART2 Open Drain Enable
      0  #0  Open drain is disabled on UART2
      1  #1  Open drain is enabled on UART2
    */
    alias UART2ODE =   Bit!(19, Mutability.read_write);

  }
  /**************************************************************************************
  * System Options Register 7
  */
  final abstract class SOPT7  : Register!(0x1018  , Access.read_write32)
  {
    /************************************************************************************
    ADC0 trigger select
      0000  #0000  External trigger pin input (EXTRG_IN)
      0001  #0001  CMP0 output
      0100  #0100  PIT trigger 0
      0101  #0101  PIT trigger 1
      1000  #1000  TPM0 overflow
      1001  #1001  TPM1 overflow
      1010  #1010  TPM2 overflow
      1100  #1100  RTC alarm
      1101  #1101  RTC seconds
      1110  #1110  LPTMR0 trigger
    */
    alias ADC0TRGSEL =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    ADC0 pretrigger select
      0  #0  Pre-trigger A
      1  #1  Pre-trigger B
    */
    alias ADC0PRETRGSEL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    ADC0 alternate trigger enable
      0  #0  TPM1 channel 0 (A) and channel 1 (B) triggers selected for ADC0.
      1  #1  Alternate trigger selected for ADC0.
    */
    alias ADC0ALTTRGEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * System Device Identification Register
  */
  final abstract class SDID  : Register!(0x1024  , Access.read_only32)
  {
    /************************************************************************************
    Pincount identification
      0000  #0000  16-pin
      0001  #0001  24-pin
      0010  #0010  32-pin
      0100  #0100  48-pin
      0101  #0101  64-pin
      0110  #0110  80-pin
      1000  #1000  100-pin
    */
    alias PINID =   BitField!(4, 0, Mutability.read_only);

    /************************************************************************************
    Device die number
    */
    alias DIEID =   BitField!(12, 7, Mutability.read_only);

    /************************************************************************************
    Device revision number
    */
    alias REVID =   BitField!(16, 12, Mutability.read_only);

    /************************************************************************************
    System SRAM Size
      0000  #0000  0.5 KB
      0001  #0001  1 KB
      0010  #0010  2 KB
      0011  #0011  4 KB
      0100  #0100  8 KB
      0101  #0101  16 KB
      0110  #0110  32 KB
      0111  #0111  64 KB
    */
    alias SRAMSIZE =   BitField!(20, 16, Mutability.read_only);

    /************************************************************************************
    Kinetis Series ID
      0001  #0001  KL family
    */
    alias SERIESID =   BitField!(24, 20, Mutability.read_only);

    /************************************************************************************
    Kinetis Sub-Family ID
      0010  #0010  KLx2 Subfamily (low end)
      0100  #0100  KLx4 Subfamily (basic analog)
      0101  #0101  KLx5 Subfamily (advanced analog)
      0110  #0110  KLx6 Subfamily (advanced analog with I2S)
    */
    alias SUBFAMID =   BitField!(28, 24, Mutability.read_only);

    /************************************************************************************
    Kinetis family ID
      0000  #0000  KL0x Family (low end)
      0001  #0001  KL1x Family (basic)
      0010  #0010  KL2x Family (USB)
      0011  #0011  KL3x Family (Segment LCD)
      0100  #0100  KL4x Family (USB and Segment LCD)
    */
    alias FAMID =   BitField!(32, 28, Mutability.read_only);

  }
  /**************************************************************************************
  * System Clock Gating Control Register 4
  */
  final abstract class SCGC4  : Register!(0x1034  , Access.read_write32)
  {
    /************************************************************************************
    I2C0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias I2C0 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    I2C1 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias I2C1 =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    UART0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias UART0 =   Bit!(11, Mutability.read_write);

    /************************************************************************************
    UART1 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias UART1 =   Bit!(12, Mutability.read_write);

    /************************************************************************************
    UART2 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias UART2 =   Bit!(13, Mutability.read_write);

    /************************************************************************************
    USB Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias USBOTG =   Bit!(19, Mutability.read_write);

    /************************************************************************************
    Comparator Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias CMP =   Bit!(20, Mutability.read_write);

    /************************************************************************************
    SPI0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias SPI0 =   Bit!(23, Mutability.read_write);

    /************************************************************************************
    SPI1 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias SPI1 =   Bit!(24, Mutability.read_write);

  }
  /**************************************************************************************
  * System Clock Gating Control Register 5
  */
  final abstract class SCGC5  : Register!(0x1038  , Access.read_write32)
  {
    /************************************************************************************
    Low Power Timer Access Control
      0  #0  Access disabled
      1  #1  Access enabled
    */
    alias LPTMR =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    TSI Access Control
      0  #0  Access disabled
      1  #1  Access enabled
    */
    alias TSI =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Port A Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PORTA =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Port B Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PORTB =   Bit!(11, Mutability.read_write);

    /************************************************************************************
    Port C Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PORTC =   Bit!(12, Mutability.read_write);

    /************************************************************************************
    Port D Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PORTD =   Bit!(13, Mutability.read_write);

    /************************************************************************************
    Port E Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PORTE =   Bit!(14, Mutability.read_write);

  }
  /**************************************************************************************
  * System Clock Gating Control Register 6
  */
  final abstract class SCGC6  : Register!(0x103C  , Access.read_write32)
  {
    /************************************************************************************
    Flash Memory Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias FTF =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    DMA Mux Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias DMAMUX =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    PIT Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias PIT =   Bit!(24, Mutability.read_write);

    /************************************************************************************
    TPM0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias TPM0 =   Bit!(25, Mutability.read_write);

    /************************************************************************************
    TPM1 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias TPM1 =   Bit!(26, Mutability.read_write);

    /************************************************************************************
    TPM2 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias TPM2 =   Bit!(27, Mutability.read_write);

    /************************************************************************************
    ADC0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias ADC0 =   Bit!(28, Mutability.read_write);

    /************************************************************************************
    RTC Access Control
      0  #0  Access and interrupts disabled
      1  #1  Access and interrupts enabled
    */
    alias RTC =   Bit!(30, Mutability.read_write);

    /************************************************************************************
    DAC0 Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias DAC0 =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * System Clock Gating Control Register 7
  */
  final abstract class SCGC7  : Register!(0x1040  , Access.read_write32)
  {
    /************************************************************************************
    DMA Clock Gate Control
      0  #0  Clock disabled
      1  #1  Clock enabled
    */
    alias DMA =   Bit!(9, Mutability.read_write);

  }
  /**************************************************************************************
  * System Clock Divider Register 1
  */
  final abstract class CLKDIV1  : Register!(0x1044  , Access.read_write32)
  {
    /************************************************************************************
    Clock 4 output divider value
      000  #000  Divide-by-1.
      001  #001  Divide-by-2.
      010  #010  Divide-by-3.
      011  #011  Divide-by-4.
      100  #100  Divide-by-5.
      101  #101  Divide-by-6.
      110  #110  Divide-by-7.
      111  #111  Divide-by-8.
    */
    alias OUTDIV4 =   BitField!(19, 16, Mutability.read_write);

    /************************************************************************************
    Clock 1 output divider value
      0000  #0000  Divide-by-1.
      0001  #0001  Divide-by-2.
      0010  #0010  Divide-by-3.
      0011  #0011  Divide-by-4.
      0100  #0100  Divide-by-5.
      0101  #0101  Divide-by-6.
      0110  #0110  Divide-by-7.
      0111  #0111  Divide-by-8.
      1000  #1000  Divide-by-9.
      1001  #1001  Divide-by-10.
      1010  #1010  Divide-by-11.
      1011  #1011  Divide-by-12.
      1100  #1100  Divide-by-13.
      1101  #1101  Divide-by-14.
      1110  #1110  Divide-by-15.
      1111  #1111  Divide-by-16.
    */
    alias OUTDIV1 =   BitField!(32, 28, Mutability.read_write);

  }
  /**************************************************************************************
  * Flash Configuration Register 1
  */
  final abstract class FCFG1  : Register!(0x104C  , Access.read_write32)
  {
    /************************************************************************************
    Flash Disable
      0  #0  Flash is enabled
      1  #1  Flash is disabled
    */
    alias FLASHDIS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Flash Doze
      0  #0  Flash remains enabled during Doze mode
      1  #1  Flash is disabled for the duration of Doze mode
    */
    alias FLASHDOZE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Program flash size
      0000  #0000  8 KB of program flash memory, 0.25 KB protection region
      0001  #0001  16 KB of program flash memory, 0.5 KB protection region
      0011  #0011  32 KB of program flash memory, 1 KB protection region
      0101  #0101  64 KB of program flash memory, 2 KB protection region
      0111  #0111  128 KB of program flash memory, 4 KB protection region
      1001  #1001  256 KB of program flash memory, 8 KB protection region
      1111  #1111  128 KB of program flash memory, 4 KB protection region
    */
    alias PFSIZE =   BitField!(28, 24, Mutability.read_only);

  }
  /**************************************************************************************
  * Flash Configuration Register 2
  */
  final abstract class FCFG2  : Register!(0x1050  , Access.read_only32)
  {
    /************************************************************************************
    Max address block
    */
    alias MAXADDR0 =   BitField!(31, 24, Mutability.read_only);

  }
  /**************************************************************************************
  * Unique Identification Register Mid-High
  */
  final abstract class UIDMH  : Register!(0x1058  , Access.read_only32)
  {
    /************************************************************************************
    Unique Identification
    */
    alias UID =   BitField!(16, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Unique Identification Register Mid Low
  */
  final abstract class UIDML  : Register!(0x105C  , Access.read_only32)
  {
    /************************************************************************************
    Unique Identification
    */
    alias UID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Unique Identification Register Low
  */
  final abstract class UIDL  : Register!(0x1060  , Access.read_only32)
  {
    /************************************************************************************
    Unique Identification
    */
    alias UID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * COP Control Register
  */
  final abstract class COPC  : Register!(0x1100  , Access.read_write32)
  {
    /************************************************************************************
    COP windowed mode
      0  #0  Normal mode
      1  #1  Windowed mode
    */
    alias COPW =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    COP Clock Select
      0  #0  Internal 1 kHz clock is source to COP
      1  #1  Bus clock is source to COP
    */
    alias COPCLKS =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    COP Watchdog Timeout
      00  #00  COP disabled
      01  #01  COP timeout after 2^5 LPO cycles or 213 bus clock cycles
      10  #10  COP timeout after 2^8 LPO cycles or 216 bus clock cycles
      11  #11  COP timeout after 2^10 LPO cycles or 218 bus clock cycles
    */
    alias COPT =   BitField!(4, 2, Mutability.read_write);

  }
  /**************************************************************************************
  * Service COP Register
  */
  final abstract class SRVCOP  : Register!(0x1104  , Access.write_only32)
  {
    /************************************************************************************
    Sevice COP Register
    */
    alias SRVCOP =   BitField!(8, 0, Mutability.write_only);

  }
}
/****************************************************************************************
  * Pin Control and Interrupts
*/
final abstract class PORTA: Peripheral!(0x40049000)
{
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR0  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR1  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR2  : Register!(0X8  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR3  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR4  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR5  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR6  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR7  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR8  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR9  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR10  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR11  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR12  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR13  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR14  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR15  : Register!(0X3C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR16  : Register!(0X40  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR17  : Register!(0X44  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR18  : Register!(0X48  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR19  : Register!(0X4C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR20  : Register!(0X50  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR21  : Register!(0X54  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR22  : Register!(0X58  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR23  : Register!(0X5C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR24  : Register!(0X60  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR25  : Register!(0X64  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR26  : Register!(0X68  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR27  : Register!(0X6C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR28  : Register!(0X70  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR29  : Register!(0X74  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR30  : Register!(0X78  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR31  : Register!(0X7C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Global Pin Control Low Register
  */
  final abstract class GPCLR  : Register!(0x80  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Global Pin Control High Register
  */
  final abstract class GPCHR  : Register!(0x84  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Interrupt Status Flag Register
  */
  final abstract class ISFR  : Register!(0xA0  , Access.read_write32)
  {
    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Pin Control and Interrupts
*/
final abstract class PORTB: Peripheral!(0x4004A000)
{
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR0  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR1  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR2  : Register!(0X8  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR3  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR4  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR5  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR6  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR7  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR8  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR9  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR10  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR11  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR12  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR13  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR14  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR15  : Register!(0X3C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR16  : Register!(0X40  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR17  : Register!(0X44  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR18  : Register!(0X48  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR19  : Register!(0X4C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR20  : Register!(0X50  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR21  : Register!(0X54  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR22  : Register!(0X58  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR23  : Register!(0X5C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR24  : Register!(0X60  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR25  : Register!(0X64  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR26  : Register!(0X68  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR27  : Register!(0X6C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR28  : Register!(0X70  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR29  : Register!(0X74  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR30  : Register!(0X78  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR31  : Register!(0X7C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Global Pin Control Low Register
  */
  final abstract class GPCLR  : Register!(0x80  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Global Pin Control High Register
  */
  final abstract class GPCHR  : Register!(0x84  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Interrupt Status Flag Register
  */
  final abstract class ISFR  : Register!(0xA0  , Access.read_write32)
  {
    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Pin Control and Interrupts
*/
final abstract class PORTC: Peripheral!(0x4004B000)
{
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR0  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR1  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR2  : Register!(0X8  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR3  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR4  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR5  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR6  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR7  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR8  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR9  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR10  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR11  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR12  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR13  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR14  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR15  : Register!(0X3C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR16  : Register!(0X40  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR17  : Register!(0X44  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR18  : Register!(0X48  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR19  : Register!(0X4C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR20  : Register!(0X50  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR21  : Register!(0X54  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR22  : Register!(0X58  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR23  : Register!(0X5C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR24  : Register!(0X60  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR25  : Register!(0X64  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR26  : Register!(0X68  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR27  : Register!(0X6C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR28  : Register!(0X70  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR29  : Register!(0X74  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR30  : Register!(0X78  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR31  : Register!(0X7C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Global Pin Control Low Register
  */
  final abstract class GPCLR  : Register!(0x80  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Global Pin Control High Register
  */
  final abstract class GPCHR  : Register!(0x84  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Interrupt Status Flag Register
  */
  final abstract class ISFR  : Register!(0xA0  , Access.read_write32)
  {
    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Pin Control and Interrupts
*/
final abstract class PORTD: Peripheral!(0x4004C000)
{
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR0  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR1  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR2  : Register!(0X8  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR3  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR4  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR5  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR6  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR7  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR8  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR9  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR10  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR11  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR12  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR13  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR14  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR15  : Register!(0X3C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR16  : Register!(0X40  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR17  : Register!(0X44  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR18  : Register!(0X48  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR19  : Register!(0X4C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR20  : Register!(0X50  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR21  : Register!(0X54  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR22  : Register!(0X58  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR23  : Register!(0X5C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR24  : Register!(0X60  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR25  : Register!(0X64  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR26  : Register!(0X68  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR27  : Register!(0X6C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR28  : Register!(0X70  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR29  : Register!(0X74  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR30  : Register!(0X78  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR31  : Register!(0X7C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Global Pin Control Low Register
  */
  final abstract class GPCLR  : Register!(0x80  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Global Pin Control High Register
  */
  final abstract class GPCHR  : Register!(0x84  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Interrupt Status Flag Register
  */
  final abstract class ISFR  : Register!(0xA0  , Access.read_write32)
  {
    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Pin Control and Interrupts
*/
final abstract class PORTE: Peripheral!(0x4004D000)
{
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR0  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR1  : Register!(0X4  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR2  : Register!(0X8  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR3  : Register!(0XC  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR4  : Register!(0X10  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR5  : Register!(0X14  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR6  : Register!(0X18  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR7  : Register!(0X1C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR8  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR9  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR10  : Register!(0X28  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR11  : Register!(0X2C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR12  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR13  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR14  : Register!(0X38  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR15  : Register!(0X3C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR16  : Register!(0X40  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR17  : Register!(0X44  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR18  : Register!(0X48  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR19  : Register!(0X4C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR20  : Register!(0X50  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR21  : Register!(0X54  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR22  : Register!(0X58  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR23  : Register!(0X5C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR24  : Register!(0X60  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR25  : Register!(0X64  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR26  : Register!(0X68  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR27  : Register!(0X6C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR28  : Register!(0X70  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR29  : Register!(0X74  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR30  : Register!(0X78  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Pin Control Register n
  */
  final abstract class PCR31  : Register!(0X7C  , Access.read_write32)
  {
    /************************************************************************************
    Pull Select
      0  #0  Internal pulldown resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
      1  #1  Internal pullup resistor is enabled on the corresponding pin, if the corresponding Port Pull Enable field is set.
    */
    alias PS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Pull Enable
      0  #0  Internal pullup or pulldown resistor is not enabled on the corresponding pin.
      1  #1  Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slew Rate Enable
      0  #0  Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
      1  #1  Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
    */
    alias SRE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Passive Filter Enable
      0  #0  Passive input filter is disabled on the corresponding pin.
      1  #1  Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
    */
    alias PFE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Drive Strength Enable
      0  #0  Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
      1  #1  High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
    */
    alias DSE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Pin Mux Control
      000  #000  Pin disabled (analog).
      001  #001  Alternative 1 (GPIO).
      010  #010  Alternative 2 (chip-specific).
      011  #011  Alternative 3 (chip-specific).
      100  #100  Alternative 4 (chip-specific).
      101  #101  Alternative 5 (chip-specific).
      110  #110  Alternative 6 (chip-specific).
      111  #111  Alternative 7 (chip-specific).
    */
    alias MUX =   BitField!(11, 8, Mutability.read_write);

    /************************************************************************************
    Interrupt Configuration
      0000  #0000  Interrupt/DMA request disabled.
      0001  #0001  DMA request on rising edge.
      0010  #0010  DMA request on falling edge.
      0011  #0011  DMA request on either edge.
      1000  #1000  Interrupt when logic zero.
      1001  #1001  Interrupt on rising edge.
      1010  #1010  Interrupt on falling edge.
      1011  #1011  Interrupt on either edge.
      1100  #1100  Interrupt when logic one.
    */
    alias IRQC =   BitField!(20, 16, Mutability.read_write);

    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   Bit!(25, Mutability.read_write);

  }
  /**************************************************************************************
  * Global Pin Control Low Register
  */
  final abstract class GPCLR  : Register!(0x80  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Global Pin Control High Register
  */
  final abstract class GPCHR  : Register!(0x84  , Access.write_only32)
  {
    /************************************************************************************
    Global Pin Write Data
    */
    alias GPWD =   BitField!(16, 0, Mutability.write_only);

    /************************************************************************************
    Global Pin Write Enable
      0  #0  Corresponding Pin Control Register is not updated with the value in GPWD.
      1  #1  Corresponding Pin Control Register is updated with the value in GPWD.
    */
    alias GPWE =   BitField!(32, 16, Mutability.write_only);

  }
  /**************************************************************************************
  * Interrupt Status Flag Register
  */
  final abstract class ISFR  : Register!(0xA0  , Access.read_write32)
  {
    /************************************************************************************
    Interrupt Status Flag
      0  #0  Configured interrupt is not detected.
      1  #1  Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic one is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
    */
    alias ISF =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Multipurpose Clock Generator module
*/
final abstract class MCG: Peripheral!(0x40064000)
{
  /**************************************************************************************
  * MCG Control 1 Register
  */
  final abstract class C1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Internal Reference Stop Enable
      0  #0  Internal reference clock is disabled in Stop mode.
      1  #1  Internal reference clock is enabled in Stop mode if IRCLKEN is set or if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
    */
    alias IREFSTEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Internal Reference Clock Enable
      0  #0  MCGIRCLK inactive.
      1  #1  MCGIRCLK active.
    */
    alias IRCLKEN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Internal Reference Select
      0  #0  External reference clock is selected.
      1  #1  The slow internal reference clock is selected.
    */
    alias IREFS =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    FLL External Reference Divider
      000  #000  If RANGE 0 = 0 , Divide Factor is 1; for all other RANGE 0 values, Divide Factor is 32.
      001  #001  If RANGE 0 = 0 , Divide Factor is 2; for all other RANGE 0 values, Divide Factor is 64.
      010  #010  If RANGE 0 = 0 , Divide Factor is 4; for all other RANGE 0 values, Divide Factor is 128.
      011  #011  If RANGE 0 = 0 , Divide Factor is 8; for all other RANGE 0 values, Divide Factor is 256.
      100  #100  If RANGE 0 = 0 , Divide Factor is 16; for all other RANGE 0 values, Divide Factor is 512.
      101  #101  If RANGE 0 = 0 , Divide Factor is 32; for all other RANGE 0 values, Divide Factor is 1024.
      110  #110  If RANGE 0 = 0 , Divide Factor is 64; for all other RANGE 0 values, Divide Factor is 1280 .
      111  #111  If RANGE 0 = 0 , Divide Factor is 128; for all other RANGE 0 values, Divide Factor is 1536 .
    */
    alias FRDIV =   BitField!(6, 3, Mutability.read_write);

    /************************************************************************************
    Clock Source Select
      00  #00  Encoding 0 - Output of FLL or PLL is selected (depends on PLLS control bit).
      01  #01  Encoding 1 - Internal reference clock is selected.
      10  #10  Encoding 2 - External reference clock is selected.
      11  #11  Encoding 3 - Reserved.
    */
    alias CLKS =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 2 Register
  */
  final abstract class C2  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Internal Reference Clock Select
      0  #0  Slow internal reference clock selected.
      1  #1  Fast internal reference clock selected.
    */
    alias IRCS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Low Power Select
      0  #0  FLL or PLL is not disabled in bypass modes.
      1  #1  FLL or PLL is disabled in bypass modes (lower power)
    */
    alias LP =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    External Reference Select
      0  #0  External reference clock requested.
      1  #1  Oscillator requested.
    */
    alias EREFS0 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    High Gain Oscillator Select
      0  #0  Configure crystal oscillator for low-power operation.
      1  #1  Configure crystal oscillator for high-gain operation.
    */
    alias HGO0 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Frequency Range Select
      00  #00  Encoding 0 - Low frequency range selected for the crystal oscillator .
      01  #01  Encoding 1 - High frequency range selected for the crystal oscillator .
    */
    alias RANGE0 =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Loss of Clock Reset Enable
      0  #0  Interrupt request is generated on a loss of OSC0 external reference clock.
      1  #1  Generate a reset request on a loss of OSC0 external reference clock.
    */
    alias LOCRE0 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 3 Register
  */
  final abstract class C3  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Slow Internal Reference Clock Trim Setting
    */
    alias SCTRIM =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 4 Register
  */
  final abstract class C4  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Slow Internal Reference Clock Fine Trim
    */
    alias SCFTRIM =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Fast Internal Reference Clock Trim Setting
    */
    alias FCTRIM =   BitField!(5, 1, Mutability.read_write);

    /************************************************************************************
    DCO Range Select
      00  #00  Encoding 0 - Low range (reset default).
      01  #01  Encoding 1 - Mid range.
      10  #10  Encoding 2 - Mid-high range.
      11  #11  Encoding 3 - High range.
    */
    alias DRST_DRS =   BitField!(7, 5, Mutability.read_write);

    /************************************************************************************
    DCO Maximum Frequency with 32.768 kHz Reference
      0  #0  DCO has a default range of 25%.
      1  #1  DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
    */
    alias DMX32 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 5 Register
  */
  final abstract class C5  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    PLL External Reference Divider
    */
    alias PRDIV0 =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    PLL Stop Enable
      0  #0  MCGPLLCLK is disabled in any of the Stop modes.
      1  #1  MCGPLLCLK is enabled if system is in Normal Stop mode.
    */
    alias PLLSTEN0 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    PLL Clock Enable
      0  #0  MCGPLLCLK is inactive.
      1  #1  MCGPLLCLK is active.
    */
    alias PLLCLKEN0 =   Bit!(7, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 6 Register
  */
  final abstract class C6  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    VCO 0 Divider
    */
    alias VDIV0 =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Clock Monitor Enable
      0  #0  External clock monitor is disabled for OSC0.
      1  #1  External clock monitor is enabled for OSC0.
    */
    alias CME0 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    PLL Select
      0  #0  FLL is selected.
      1  #1  PLL is selected (PRDIV 0 need to be programmed to the correct divider to generate a PLL reference clock in the range of 2-4 MHz prior to setting the PLLS bit).
    */
    alias PLLS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Loss of Lock Interrrupt Enable
      0  #0  No interrupt request is generated on loss of lock.
      1  #1  Generate an interrupt request on loss of lock.
    */
    alias LOLIE0 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Status Register
  */
  final abstract class S  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    Internal Reference Clock Status
      0  #0  Source of internal reference clock is the slow clock (32 kHz IRC).
      1  #1  Source of internal reference clock is the fast clock (4 MHz IRC).
    */
    alias IRCST =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    OSC Initialization
    */
    alias OSCINIT0 =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Clock Mode Status
      00  #00  Encoding 0 - Output of the FLL is selected (reset default).
      01  #01  Encoding 1 - Internal reference clock is selected.
      10  #10  Encoding 2 - External reference clock is selected.
      11  #11  Encoding 3 - Output of the PLL is selected.
    */
    alias CLKST =   BitField!(4, 2, Mutability.read_only);

    /************************************************************************************
    Internal Reference Status
      0  #0  Source of FLL reference clock is the external reference clock.
      1  #1  Source of FLL reference clock is the internal reference clock.
    */
    alias IREFST =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    PLL Select Status
      0  #0  Source of PLLS clock is FLL clock.
      1  #1  Source of PLLS clock is PLL output clock.
    */
    alias PLLST =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Lock Status
      0  #0  PLL is currently unlocked.
      1  #1  PLL is currently locked.
    */
    alias LOCK0 =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Loss of Lock Status
      0  #0  PLL has not lost lock since LOLS 0 was last cleared.
      1  #1  PLL has lost lock since LOLS 0 was last cleared.
    */
    alias LOLS0 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Status and Control Register
  */
  final abstract class SC  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    OSC0 Loss of Clock Status
      0  #0  Loss of OSC0 has not occurred.
      1  #1  Loss of OSC0 has occurred.
    */
    alias LOCS0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Fast Clock Internal Reference Divider
      000  #000  Divide Factor is 1
      001  #001  Divide Factor is 2.
      010  #010  Divide Factor is 4.
      011  #011  Divide Factor is 8.
      100  #100  Divide Factor is 16
      101  #101  Divide Factor is 32
      110  #110  Divide Factor is 64
      111  #111  Divide Factor is 128.
    */
    alias FCRDIV =   BitField!(4, 1, Mutability.read_write);

    /************************************************************************************
    FLL Filter Preserve Enable
      0  #0  FLL filter and FLL frequency will reset on changes to currect clock mode.
      1  #1  Fll filter and FLL frequency retain their previous values during new clock mode change.
    */
    alias FLTPRSRV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Automatic Trim Machine Fail Flag
      0  #0  Automatic Trim Machine completed normally.
      1  #1  Automatic Trim Machine failed.
    */
    alias ATMF =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Automatic Trim Machine Select
      0  #0  32 kHz Internal Reference Clock selected.
      1  #1  4 MHz Internal Reference Clock selected.
    */
    alias ATMS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Automatic Trim Machine Enable
      0  #0  Auto Trim Machine disabled.
      1  #1  Auto Trim Machine enabled.
    */
    alias ATME =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Auto Trim Compare Value High Register
  */
  final abstract class ATCVH  : Register!(0xA  , Access.read_write8)
  {
    /************************************************************************************
    ATM Compare Value High
    */
    alias ATCVH =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Auto Trim Compare Value Low Register
  */
  final abstract class ATCVL  : Register!(0xB  , Access.read_write8)
  {
    /************************************************************************************
    ATM Compare Value Low
    */
    alias ATCVL =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 7 Register
  */
  final abstract class C7  : Register!(0xC  , Access.read_only8)
  {
  }
  /**************************************************************************************
  * MCG Control 8 Register
  */
  final abstract class C8  : Register!(0xD  , Access.read_write8)
  {
    /************************************************************************************
    PLL Loss of Lock Reset Enable
      0  #0  Interrupt request is generated on a PLL loss of lock indication. The PLL loss of lock interrupt enable bit must also be set to generate the interrupt request.
      1  #1  Generate a reset request on a PLL loss of lock indication.
    */
    alias LOLRE =   Bit!(7, Mutability.read_write);

  }
  /**************************************************************************************
  * MCG Control 9 Register
  */
  final abstract class C9  : Register!(0xE  , Access.read_only8)
  {
  }
  /**************************************************************************************
  * MCG Control 10 Register
  */
  final abstract class C10  : Register!(0xF  , Access.read_only8)
  {
  }
}
/****************************************************************************************
  * Oscillator
*/
final abstract class OSC0: Peripheral!(0x40065000)
{
  /**************************************************************************************
  * OSC Control Register
  */
  final abstract class CR  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Oscillator 16 pF Capacitor Load Configure
      0  #0  Disable the selection.
      1  #1  Add 16 pF capacitor to the oscillator load.
    */
    alias SC16P =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Oscillator 8 pF Capacitor Load Configure
      0  #0  Disable the selection.
      1  #1  Add 8 pF capacitor to the oscillator load.
    */
    alias SC8P =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Oscillator 4 pF Capacitor Load Configure
      0  #0  Disable the selection.
      1  #1  Add 4 pF capacitor to the oscillator load.
    */
    alias SC4P =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Oscillator 2 pF Capacitor Load Configure
      0  #0  Disable the selection.
      1  #1  Add 2 pF capacitor to the oscillator load.
    */
    alias SC2P =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    External Reference Stop Enable
      0  #0  External reference clock is disabled in Stop mode.
      1  #1  External reference clock stays enabled in Stop mode if ERCLKEN is set before entering Stop mode.
    */
    alias EREFSTEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    External Reference Enable
      0  #0  External reference clock is inactive.
      1  #1  External reference clock is enabled.
    */
    alias ERCLKEN =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Inter-Integrated Circuit
*/
final abstract class I2C0: Peripheral!(0x40066000)
{
  /**************************************************************************************
  * I2C Address Register 1
  */
  final abstract class A1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Address
    */
    alias AD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Frequency Divider register
  */
  final abstract class F  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    ClockRate
    */
    alias ICR =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    no description available
      00  #00  mul = 1
      01  #01  mul = 2
      10  #10  mul = 4
    */
    alias MULT =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Control Register 1
  */
  final abstract class C1  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    DMA Enable
      0  #0  All DMA signalling disabled.
      1  #1  DMA transfer is enabled and the following conditions trigger the DMA request: While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received matches the A1 register or is general call address. If any address matching occurs, IAAS and TCF are set. If the direction of transfer is known from master to slave, then it is not required to check the SRW. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.
    */
    alias DMAEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Enable
      0  #0  Normal operation. No interrupt generated when address matching in low power mode.
      1  #1  Enables the wakeup function in low power mode.
    */
    alias WUEN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Repeat START
    */
    alias RSTA =   Bit!(3, Mutability.write_only);

    /************************************************************************************
    Transmit Acknowledge Enable
      0  #0  An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
      1  #1  No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).
    */
    alias TXAK =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Transmit Mode Select
      0  #0  Receive
      1  #1  Transmit
    */
    alias TX =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Master Mode Select
      0  #0  Slave mode
      1  #1  Master mode
    */
    alias MST =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    I2C Interrupt Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias IICIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    I2C Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias IICEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Status register
  */
  final abstract class S  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Receive Acknowledge
      0  #0  Acknowledge signal was received after the completion of one byte of data transmission on the bus
      1  #1  No acknowledge signal detected
    */
    alias RXAK =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Interrupt Flag
      0  #0  No interrupt pending
      1  #1  Interrupt pending
    */
    alias IICIF =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slave Read/Write
      0  #0  Slave receive, master writing to slave
      1  #1  Slave transmit, master reading from slave
    */
    alias SRW =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Range Address Match
      0  #0  Not addressed
      1  #1  Addressed as a slave
    */
    alias RAM =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Arbitration Lost
      0  #0  Standard bus operation.
      1  #1  Loss of arbitration.
    */
    alias ARBL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Bus Busy
      0  #0  Bus is idle
      1  #1  Bus is busy
    */
    alias BUSY =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Addressed As A Slave
      0  #0  Not addressed
      1  #1  Addressed as a slave
    */
    alias IAAS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Transfer Complete Flag
      0  #0  Transfer in progress
      1  #1  Transfer complete
    */
    alias TCF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * I2C Data I/O register
  */
  final abstract class D  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    Data
    */
    alias DATA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Control Register 2
  */
  final abstract class C2  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Slave Address
    */
    alias AD =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Range Address Matching Enable
      0  #0  Range mode disabled. No address match occurs for an address within the range of values of the A1 and RA registers.
      1  #1  Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.
    */
    alias RMEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Slave Baud Rate Control
      0  #0  The slave baud rate follows the master baud rate and clock stretching may occur
      1  #1  Slave baud rate is independent of the master baud rate
    */
    alias SBRC =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    High Drive Select
      0  #0  Normal drive mode
      1  #1  High drive mode
    */
    alias HDRS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Address Extension
      0  #0  7-bit address scheme
      1  #1  10-bit address scheme
    */
    alias ADEXT =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    General Call Address Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias GCAEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Programmable Input Glitch Filter register
  */
  final abstract class FLT  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    I2C Programmable Filter Factor
      0  #0  No filter/bypass
    */
    alias FLT =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    I2C Bus Start Detect Flag
      0  #0  No start happens on I2C bus
      1  #1  Start detected on I2C bus
    */
    alias STARTF =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    I2C Bus Stop or Start Interrupt Enable
      0  #0  Stop or start detection interrupt is disabled
      1  #1  Stop or start detection interrupt is enabled
    */
    alias SSIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    I2C Bus Stop Detect Flag
      0  #0  No stop happens on I2C bus
      1  #1  Stop detected on I2C bus
    */
    alias STOPF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Stop Hold Enable
      0  #0  Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
      1  #1  Stop holdoff is enabled.
    */
    alias SHEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Range Address register
  */
  final abstract class RA  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    Range Slave Address
    */
    alias RAD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SMBus Control and Status register
  */
  final abstract class SMB  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    SHTF2 Interrupt Enable
      0  #0  SHTF2 interrupt is disabled
      1  #1  SHTF2 interrupt is enabled
    */
    alias SHTF2IE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    SCL High Timeout Flag 2
      0  #0  No SCL high and SDA low timeout occurs
      1  #1  SCL high and SDA low timeout occurs
    */
    alias SHTF2 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    SCL High Timeout Flag 1
      0  #0  No SCL high and SDA high timeout occurs
      1  #1  SCL high and SDA high timeout occurs
    */
    alias SHTF1 =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    SCL Low Timeout Flag
      0  #0  No low timeout occurs
      1  #1  Low timeout occurs
    */
    alias SLTF =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Timeout Counter Clock Select
      0  #0  Timeout counter counts at the frequency of the bus clock / 64
      1  #1  Timeout counter counts at the frequency of the bus clock
    */
    alias TCKSEL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Second I2C Address Enable
      0  #0  I2C address register 2 matching is disabled
      1  #1  I2C address register 2 matching is enabled
    */
    alias SIICAEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SMBus Alert Response Address Enable
      0  #0  SMBus alert response address matching is disabled
      1  #1  SMBus alert response address matching is enabled
    */
    alias ALERTEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Fast NACK/ACK Enable
      0  #0  An ACK or NACK is sent on the following receiving data byte
      1  #1  Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.
    */
    alias FACK =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Address Register 2
  */
  final abstract class A2  : Register!(0x9  , Access.read_write8)
  {
    /************************************************************************************
    SMBus Address
    */
    alias SAD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SCL Low Timeout Register High
  */
  final abstract class SLTH  : Register!(0xA  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias SSLT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SCL Low Timeout Register Low
  */
  final abstract class SLTL  : Register!(0xB  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias SSLT =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Inter-Integrated Circuit
*/
final abstract class I2C1: Peripheral!(0x40067000)
{
  /**************************************************************************************
  * I2C Address Register 1
  */
  final abstract class A1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Address
    */
    alias AD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Frequency Divider register
  */
  final abstract class F  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    ClockRate
    */
    alias ICR =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    no description available
      00  #00  mul = 1
      01  #01  mul = 2
      10  #10  mul = 4
    */
    alias MULT =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Control Register 1
  */
  final abstract class C1  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    DMA Enable
      0  #0  All DMA signalling disabled.
      1  #1  DMA transfer is enabled and the following conditions trigger the DMA request: While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic) While FACK = 0, the first byte received matches the A1 register or is general call address. If any address matching occurs, IAAS and TCF are set. If the direction of transfer is known from master to slave, then it is not required to check the SRW. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.
    */
    alias DMAEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Enable
      0  #0  Normal operation. No interrupt generated when address matching in low power mode.
      1  #1  Enables the wakeup function in low power mode.
    */
    alias WUEN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Repeat START
    */
    alias RSTA =   Bit!(3, Mutability.write_only);

    /************************************************************************************
    Transmit Acknowledge Enable
      0  #0  An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
      1  #1  No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).
    */
    alias TXAK =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Transmit Mode Select
      0  #0  Receive
      1  #1  Transmit
    */
    alias TX =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Master Mode Select
      0  #0  Slave mode
      1  #1  Master mode
    */
    alias MST =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    I2C Interrupt Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias IICIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    I2C Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias IICEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Status register
  */
  final abstract class S  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Receive Acknowledge
      0  #0  Acknowledge signal was received after the completion of one byte of data transmission on the bus
      1  #1  No acknowledge signal detected
    */
    alias RXAK =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Interrupt Flag
      0  #0  No interrupt pending
      1  #1  Interrupt pending
    */
    alias IICIF =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Slave Read/Write
      0  #0  Slave receive, master writing to slave
      1  #1  Slave transmit, master reading from slave
    */
    alias SRW =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Range Address Match
      0  #0  Not addressed
      1  #1  Addressed as a slave
    */
    alias RAM =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Arbitration Lost
      0  #0  Standard bus operation.
      1  #1  Loss of arbitration.
    */
    alias ARBL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Bus Busy
      0  #0  Bus is idle
      1  #1  Bus is busy
    */
    alias BUSY =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Addressed As A Slave
      0  #0  Not addressed
      1  #1  Addressed as a slave
    */
    alias IAAS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Transfer Complete Flag
      0  #0  Transfer in progress
      1  #1  Transfer complete
    */
    alias TCF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * I2C Data I/O register
  */
  final abstract class D  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    Data
    */
    alias DATA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Control Register 2
  */
  final abstract class C2  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Slave Address
    */
    alias AD =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Range Address Matching Enable
      0  #0  Range mode disabled. No address match occurs for an address within the range of values of the A1 and RA registers.
      1  #1  Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.
    */
    alias RMEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Slave Baud Rate Control
      0  #0  The slave baud rate follows the master baud rate and clock stretching may occur
      1  #1  Slave baud rate is independent of the master baud rate
    */
    alias SBRC =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    High Drive Select
      0  #0  Normal drive mode
      1  #1  High drive mode
    */
    alias HDRS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Address Extension
      0  #0  7-bit address scheme
      1  #1  10-bit address scheme
    */
    alias ADEXT =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    General Call Address Enable
      0  #0  Disabled
      1  #1  Enabled
    */
    alias GCAEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Programmable Input Glitch Filter register
  */
  final abstract class FLT  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    I2C Programmable Filter Factor
      0  #0  No filter/bypass
    */
    alias FLT =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    I2C Bus Start Detect Flag
      0  #0  No start happens on I2C bus
      1  #1  Start detected on I2C bus
    */
    alias STARTF =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    I2C Bus Stop or Start Interrupt Enable
      0  #0  Stop or start detection interrupt is disabled
      1  #1  Stop or start detection interrupt is enabled
    */
    alias SSIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    I2C Bus Stop Detect Flag
      0  #0  No stop happens on I2C bus
      1  #1  Stop detected on I2C bus
    */
    alias STOPF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Stop Hold Enable
      0  #0  Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
      1  #1  Stop holdoff is enabled.
    */
    alias SHEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Range Address register
  */
  final abstract class RA  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    Range Slave Address
    */
    alias RAD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SMBus Control and Status register
  */
  final abstract class SMB  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    SHTF2 Interrupt Enable
      0  #0  SHTF2 interrupt is disabled
      1  #1  SHTF2 interrupt is enabled
    */
    alias SHTF2IE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    SCL High Timeout Flag 2
      0  #0  No SCL high and SDA low timeout occurs
      1  #1  SCL high and SDA low timeout occurs
    */
    alias SHTF2 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    SCL High Timeout Flag 1
      0  #0  No SCL high and SDA high timeout occurs
      1  #1  SCL high and SDA high timeout occurs
    */
    alias SHTF1 =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    SCL Low Timeout Flag
      0  #0  No low timeout occurs
      1  #1  Low timeout occurs
    */
    alias SLTF =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Timeout Counter Clock Select
      0  #0  Timeout counter counts at the frequency of the bus clock / 64
      1  #1  Timeout counter counts at the frequency of the bus clock
    */
    alias TCKSEL =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Second I2C Address Enable
      0  #0  I2C address register 2 matching is disabled
      1  #1  I2C address register 2 matching is enabled
    */
    alias SIICAEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SMBus Alert Response Address Enable
      0  #0  SMBus alert response address matching is disabled
      1  #1  SMBus alert response address matching is enabled
    */
    alias ALERTEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Fast NACK/ACK Enable
      0  #0  An ACK or NACK is sent on the following receiving data byte
      1  #1  Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.
    */
    alias FACK =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C Address Register 2
  */
  final abstract class A2  : Register!(0x9  , Access.read_write8)
  {
    /************************************************************************************
    SMBus Address
    */
    alias SAD =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SCL Low Timeout Register High
  */
  final abstract class SLTH  : Register!(0xA  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias SSLT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * I2C SCL Low Timeout Register Low
  */
  final abstract class SLTL  : Register!(0xB  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias SSLT =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Universal Asynchronous Receiver/Transmitter
*/
final abstract class UART0: Peripheral!(0x4006A000)
{
  /**************************************************************************************
  * UART Baud Rate Register High
  */
  final abstract class BDH  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor.
    */
    alias SBR =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Stop Bit Number Select
      0  #0  One stop bit.
      1  #1  Two stop bit.
    */
    alias SBNS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    RX Input Active Edge Interrupt Enable (for RXEDGIF)
      0  #0  Hardware interrupts from UART _S2[RXEDGIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART _S2[RXEDGIF] flag is 1.
    */
    alias RXEDGIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Enable (for LBKDIF)
      0  #0  Hardware interrupts from UART _S2[LBKDIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART _S2[LBKDIF] flag is 1.
    */
    alias LBKDIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Baud Rate Register Low
  */
  final abstract class BDL  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor
    */
    alias SBR =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 1
  */
  final abstract class C1  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Parity Type
      0  #0  Even parity.
      1  #1  Odd parity.
    */
    alias PT =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Parity Enable
      0  #0  No hardware parity generation or checking.
      1  #1  Parity enabled.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Idle Line Type Select
      0  #0  Idle character bit count starts after start bit.
      1  #1  Idle character bit count starts after stop bit.
    */
    alias ILT =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Method Select
      0  #0  Idle-line wakeup.
      1  #1  Address-mark wakeup.
    */
    alias WAKE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    9-Bit or 8-Bit Mode Select
      0  #0  Receiver and transmitter use 8-bit data characters.
      1  #1  Receiver and transmitter use 9-bit data characters.
    */
    alias M =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Source Select
      0  #0  Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the UART does not use the UART _RX pins.
      1  #1  Single-wire UART mode where the UART _TX pin is connected to the transmitter output and receiver input.
    */
    alias RSRC =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Doze Enable
      0  #0  UART is enabled in Wait mode.
      1  #1  UART is disabled in Wait mode.
    */
    alias DOZEEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Loop Mode Select
      0  #0  Normal operation - UART _RX and UART _TX use separate pins.
      1  #1  Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input. (See RSRC bit.) UART _RX pin is not used by UART .
    */
    alias LOOPS =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 2
  */
  final abstract class C2  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Send Break
      0  #0  Normal transmitter operation.
      1  #1  Queue break character(s) to be sent.
    */
    alias SBK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Control
      0  #0  Normal UART receiver operation.
      1  #1  UART receiver in standby waiting for wakeup condition.
    */
    alias RWU =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receiver Enable
      0  #0  Receiver disabled.
      1  #1  Receiver enabled.
    */
    alias RE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Transmitter Enable
      0  #0  Transmitter disabled.
      1  #1  Transmitter enabled.
    */
    alias TE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Idle Line Interrupt Enable for IDLE
      0  #0  Hardware interrupts from IDLE disabled; use polling.
      1  #1  Hardware interrupt requested when IDLE flag is 1.
    */
    alias ILIE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Interrupt Enable for RDRF
      0  #0  Hardware interrupts from RDRF disabled; use polling.
      1  #1  Hardware interrupt requested when RDRF flag is 1.
    */
    alias RIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmission Complete Interrupt Enable for TC
      0  #0  Hardware interrupts from TC disabled; use polling.
      1  #1  Hardware interrupt requested when TC flag is 1.
    */
    alias TCIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Transmit Interrupt Enable for TDRE
      0  #0  Hardware interrupts from TDRE disabled; use polling.
      1  #1  Hardware interrupt requested when TDRE flag is 1.
    */
    alias TIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Status Register 1
  */
  final abstract class S1  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    Parity Error Flag
      0  #0  No parity error.
      1  #1  Parity error.
    */
    alias PF =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Framing Error Flag
      0  #0  No framing error detected. This does not guarantee the framing is correct.
      1  #1  Framing error.
    */
    alias FE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Noise Flag
      0  #0  No noise detected.
      1  #1  Noise detected in the received character in UART _D.
    */
    alias NF =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receiver Overrun Flag
      0  #0  No overrun.
      1  #1  Receive overrun (new UART data lost).
    */
    alias OR =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Idle Line Flag
      0  #0  No idle line detected.
      1  #1  Idle line was detected.
    */
    alias IDLE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receive Data Register Full Flag
      0  #0  Receive data buffer empty.
      1  #1  Receive data buffer full.
    */
    alias RDRF =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Transmission Complete Flag
      0  #0  Transmitter active (sending data, a preamble, or a break).
      1  #1  Transmitter idle (transmission activity complete).
    */
    alias TC =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Transmit Data Register Empty Flag
      0  #0  Transmit data buffer full.
      1  #1  Transmit data buffer empty.
    */
    alias TDRE =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * UART Status Register 2
  */
  final abstract class S2  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Receiver Active Flag
      0  #0  UART receiver idle waiting for a start bit.
      1  #1  UART receiver active ( UART _RXD input not idle).
    */
    alias RAF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    LIN Break Detection Enable
      0  #0  Break character is detected at length 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
      1  #1  Break character is detected at length of 11 bit times (if M = 0, SBNS = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
    */
    alias LBKDE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Break Character Generation Length
      0  #0  Break character is transmitted with length of 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
      1  #1  Break character is transmitted with length of 13 bit times (if M = 0, SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
    */
    alias BRK13 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receive Wake Up Idle Detect
      0  #0  During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character.
      1  #1  During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character.
    */
    alias RWUID =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Receive Data Inversion
      0  #0  Receive data not inverted.
      1  #1  Receive data inverted.
    */
    alias RXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    MSB First
      0  #0  LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
      1  #1  MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of C1[M], C1[PE] and C4[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of C1[M] and C1[PE].
    */
    alias MSBF =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    UART _RX Pin Active Edge Interrupt Flag
      0  #0  No active edge on the receive pin has occurred.
      1  #1  An active edge on the receive pin has occurred.
    */
    alias RXEDGIF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Flag
      0  #0  No LIN break character has been detected.
      1  #1  LIN break character has been detected.
    */
    alias LBKDIF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 3
  */
  final abstract class C3  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    Parity Error Interrupt Enable
      0  #0  PF interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when PF is set.
    */
    alias PEIE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Framing Error Interrupt Enable
      0  #0  FE interrupts disabled; use polling.
      1  #1  Hardware interrupt requested when FE is set.
    */
    alias FEIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Noise Error Interrupt Enable
      0  #0  NF interrupts disabled; use polling.
      1  #1  Hardware interrupt requested when NF is set.
    */
    alias NEIE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Overrun Interrupt Enable
      0  #0  OR interrupts disabled; use polling.
      1  #1  Hardware interrupt requested when OR is set.
    */
    alias ORIE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Transmit Data Inversion
      0  #0  Transmit data not inverted.
      1  #1  Transmit data inverted.
    */
    alias TXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    UART _TX Pin Direction in Single-Wire Mode
      0  #0  UART _TXD pin is an input in single-wire mode.
      1  #1  UART _TXD pin is an output in single-wire mode.
    */
    alias TXDIR =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Receive Bit 9 / Transmit Bit 8
    */
    alias R9T8 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Receive Bit 8 / Transmit Bit 9
    */
    alias R8T9 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Data Register
  */
  final abstract class D  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias R0T0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R1T1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R2T2 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R3T3 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R4T4 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R5T5 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R6T6 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R7T7 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Match Address Registers 1
  */
  final abstract class MA1  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    Match Address
    */
    alias MA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Match Address Registers 2
  */
  final abstract class MA2  : Register!(0x9  , Access.read_write8)
  {
    /************************************************************************************
    Match Address
    */
    alias MA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 4
  */
  final abstract class C4  : Register!(0xA  , Access.read_write8)
  {
    /************************************************************************************
    Over Sampling Ratio
    */
    alias OSR =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    10-bit Mode select
      0  #0  Receiver and transmitter use 8-bit or 9-bit data characters.
      1  #1  Receiver and transmitter use 10-bit data characters.
    */
    alias M10 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Match Address Mode Enable 2
      0  #0  All data received is transferred to the data buffer if MAEN1 is cleared.
      1  #1  All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
    */
    alias MAEN2 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Match Address Mode Enable 1
      0  #0  All data received is transferred to the data buffer if MAEN2 is cleared.
      1  #1  All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
    */
    alias MAEN1 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 5
  */
  final abstract class C5  : Register!(0xB  , Access.read_write8)
  {
    /************************************************************************************
    Resynchronization Disable
      0  #0  Resynchronization during received data word is supported
      1  #1  Resynchronization during received data word is disabled
    */
    alias RESYNCDIS =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Both Edge Sampling
      0  #0  Receiver samples input data using the rising edge of the baud rate clock.
      1  #1  Receiver samples input data using the rising and falling edge of the baud rate clock.
    */
    alias BOTHEDGE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receiver Full DMA Enable
      0  #0  DMA request disabled.
      1  #1  DMA request enabled.
    */
    alias RDMAE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmitter DMA Enable
      0  #0  DMA request disabled.
      1  #1  DMA request enabled.
    */
    alias TDMAE =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Universal Asynchronous Receiver/Transmitter (UART)
*/
final abstract class UART1: Peripheral!(0x4006B000)
{
  /**************************************************************************************
  * UART Baud Rate Register: High
  */
  final abstract class BDH  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor.
    */
    alias SBR =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Stop Bit Number Select
      0  #0  One stop bit.
      1  #1  Two stop bit.
    */
    alias SBNS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    RxD Input Active Edge Interrupt Enable (for RXEDGIF)
      0  #0  Hardware interrupts from UART_S2[RXEDGIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART_S2[RXEDGIF] flag is 1.
    */
    alias RXEDGIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Enable (for LBKDIF)
      0  #0  Hardware interrupts from UART_S2[LBKDIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART_S2[LBKDIF] flag is 1.
    */
    alias LBKDIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Baud Rate Register: Low
  */
  final abstract class BDL  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor
    */
    alias SBR =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 1
  */
  final abstract class C1  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Parity Type
      0  #0  Even parity.
      1  #1  Odd parity.
    */
    alias PT =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Parity Enable
      0  #0  No hardware parity generation or checking.
      1  #1  Parity enabled.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Idle Line Type Select
      0  #0  Idle character bit count starts after start bit.
      1  #1  Idle character bit count starts after stop bit.
    */
    alias ILT =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Method Select
      0  #0  Idle-line wakeup.
      1  #1  Address-mark wakeup.
    */
    alias WAKE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    9-Bit or 8-Bit Mode Select
      0  #0  Normal - start + 8 data bits (lsb first) + stop.
      1  #1  Receiver and transmitter use 9-bit data characters start + 8 data bits (lsb first) + 9th data bit + stop.
    */
    alias M =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Source Select
      0  #0  Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the UART does not use the RxD pins.
      1  #1  Single-wire UART mode where the TxD pin is connected to the transmitter output and receiver input.
    */
    alias RSRC =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    UART Stops in Wait Mode
      0  #0  UART clocks continue to run in wait mode so the UART can be the source of an interrupt that wakes up the CPU.
      1  #1  UART clocks freeze while CPU is in wait mode.
    */
    alias UARTSWAI =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Loop Mode Select
      0  #0  Normal operation - RxD and TxD use separate pins.
      1  #1  Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input. (See RSRC bit.) RxD pin is not used by UART.
    */
    alias LOOPS =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 2
  */
  final abstract class C2  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Send Break
      0  #0  Normal transmitter operation.
      1  #1  Queue break character(s) to be sent.
    */
    alias SBK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Control
      0  #0  Normal UART receiver operation.
      1  #1  UART receiver in standby waiting for wakeup condition.
    */
    alias RWU =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receiver Enable
      0  #0  Receiver off.
      1  #1  Receiver on.
    */
    alias RE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Transmitter Enable
      0  #0  Transmitter off.
      1  #1  Transmitter on.
    */
    alias TE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Idle Line Interrupt Enable for IDLE
      0  #0  Hardware interrupts from IDLE disabled; use polling.
      1  #1  Hardware interrupt requested when IDLE flag is 1.
    */
    alias ILIE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Interrupt Enable for RDRF
      0  #0  Hardware interrupts from RDRF disabled; use polling.
      1  #1  Hardware interrupt requested when RDRF flag is 1.
    */
    alias RIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmission Complete Interrupt Enable for TC
      0  #0  Hardware interrupts from TC disabled; use polling.
      1  #1  Hardware interrupt requested when TC flag is 1.
    */
    alias TCIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Transmit Interrupt Enable for TDRE
      0  #0  Hardware interrupts from TDRE disabled; use polling.
      1  #1  Hardware interrupt requested when TDRE flag is 1.
    */
    alias TIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Status Register 1
  */
  final abstract class S1  : Register!(0x4  , Access.read_only8)
  {
    /************************************************************************************
    Parity Error Flag
      0  #0  No parity error.
      1  #1  Parity error.
    */
    alias PF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Framing Error Flag
      0  #0  No framing error detected. This does not guarantee the framing is correct.
      1  #1  Framing error.
    */
    alias FE =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Noise Flag
      0  #0  No noise detected.
      1  #1  Noise detected in the received character in UART_D.
    */
    alias NF =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Receiver Overrun Flag
      0  #0  No overrun.
      1  #1  Receive overrun (new UART data lost).
    */
    alias OR =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Idle Line Flag
      0  #0  No idle line detected.
      1  #1  Idle line was detected.
    */
    alias IDLE =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    Receive Data Register Full Flag
      0  #0  Receive data register empty.
      1  #1  Receive data register full.
    */
    alias RDRF =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Transmission Complete Flag
      0  #0  Transmitter active (sending data, a preamble, or a break).
      1  #1  Transmitter idle (transmission activity complete).
    */
    alias TC =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Transmit Data Register Empty Flag
      0  #0  Transmit data register (buffer) full.
      1  #1  Transmit data register (buffer) empty.
    */
    alias TDRE =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * UART Status Register 2
  */
  final abstract class S2  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Receiver Active Flag
      0  #0  UART receiver idle waiting for a start bit.
      1  #1  UART receiver active (RxD input not idle).
    */
    alias RAF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    LIN Break Detection Enable
      0  #0  Break character is detected at length 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1).
      1  #1  Break character is detected at length of 11 bit times (if M = 0, SBNS = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 13 (if M = 1, SBNS = 1).
    */
    alias LBKDE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Break Character Generation Length
      0  #0  Break character is transmitted with length of 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1).
      1  #1  Break character is transmitted with length of 13 bit times (if M = 0, SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1, SBNS = 1).
    */
    alias BRK13 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receive Wake Up Idle Detect
      0  #0  During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character.
      1  #1  During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character.
    */
    alias RWUID =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Receive Data Inversion
      0  #0  Receive data not inverted.
      1  #1  Receive data inverted.
    */
    alias RXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    RxD Pin Active Edge Interrupt Flag
      0  #0  No active edge on the receive pin has occurred.
      1  #1  An active edge on the receive pin has occurred.
    */
    alias RXEDGIF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Flag
      0  #0  No LIN break character has been detected.
      1  #1  LIN break character has been detected.
    */
    alias LBKDIF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 3
  */
  final abstract class C3  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    Parity Error Interrupt Enable
      0  #0  PF interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when PF is set.
    */
    alias PEIE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Framing Error Interrupt Enable
      0  #0  FE interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when FE is set.
    */
    alias FEIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Noise Error Interrupt Enable
      0  #0  NF interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when NF is set.
    */
    alias NEIE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Overrun Interrupt Enable
      0  #0  OR interrupts disabled; use polling.
      1  #1  Hardware interrupt requested when OR is set.
    */
    alias ORIE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Transmit Data Inversion
      0  #0  Transmit data not inverted.
      1  #1  Transmit data inverted.
    */
    alias TXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    TxD Pin Direction in Single-Wire Mode
      0  #0  TxD pin is an input in single-wire mode.
      1  #1  TxD pin is an output in single-wire mode.
    */
    alias TXDIR =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Ninth Data Bit for Transmitter
    */
    alias T8 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Ninth Data Bit for Receiver
    */
    alias R8 =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * UART Data Register
  */
  final abstract class D  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias R0T0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R1T1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R2T2 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R3T3 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R4T4 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R5T5 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R6T6 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R7T7 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 4
  */
  final abstract class C4  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    Receiver Full DMA Select
      0  #0  If RIE is set and the RDRF flag is set, the RDRF interrupt request signal is asserted to request interrupt service.
      1  #1  If RIE is set and the RDRF flag is set, the RDRF DMA request signal is asserted to request a DMA transfer.
    */
    alias RDMAS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmitter DMA Select
      0  #0  If TIE is set and the TDRE flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
      1  #1  If TIE is set and the TDRE flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.
    */
    alias TDMAS =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Universal Asynchronous Receiver/Transmitter (UART)
*/
final abstract class UART2: Peripheral!(0x4006C000)
{
  /**************************************************************************************
  * UART Baud Rate Register: High
  */
  final abstract class BDH  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor.
    */
    alias SBR =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Stop Bit Number Select
      0  #0  One stop bit.
      1  #1  Two stop bit.
    */
    alias SBNS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    RxD Input Active Edge Interrupt Enable (for RXEDGIF)
      0  #0  Hardware interrupts from UART_S2[RXEDGIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART_S2[RXEDGIF] flag is 1.
    */
    alias RXEDGIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Enable (for LBKDIF)
      0  #0  Hardware interrupts from UART_S2[LBKDIF] disabled (use polling).
      1  #1  Hardware interrupt requested when UART_S2[LBKDIF] flag is 1.
    */
    alias LBKDIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Baud Rate Register: Low
  */
  final abstract class BDL  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Baud Rate Modulo Divisor
    */
    alias SBR =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 1
  */
  final abstract class C1  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Parity Type
      0  #0  Even parity.
      1  #1  Odd parity.
    */
    alias PT =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Parity Enable
      0  #0  No hardware parity generation or checking.
      1  #1  Parity enabled.
    */
    alias PE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Idle Line Type Select
      0  #0  Idle character bit count starts after start bit.
      1  #1  Idle character bit count starts after stop bit.
    */
    alias ILT =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Method Select
      0  #0  Idle-line wakeup.
      1  #1  Address-mark wakeup.
    */
    alias WAKE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    9-Bit or 8-Bit Mode Select
      0  #0  Normal - start + 8 data bits (lsb first) + stop.
      1  #1  Receiver and transmitter use 9-bit data characters start + 8 data bits (lsb first) + 9th data bit + stop.
    */
    alias M =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Source Select
      0  #0  Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the UART does not use the RxD pins.
      1  #1  Single-wire UART mode where the TxD pin is connected to the transmitter output and receiver input.
    */
    alias RSRC =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    UART Stops in Wait Mode
      0  #0  UART clocks continue to run in wait mode so the UART can be the source of an interrupt that wakes up the CPU.
      1  #1  UART clocks freeze while CPU is in wait mode.
    */
    alias UARTSWAI =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Loop Mode Select
      0  #0  Normal operation - RxD and TxD use separate pins.
      1  #1  Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input. (See RSRC bit.) RxD pin is not used by UART.
    */
    alias LOOPS =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 2
  */
  final abstract class C2  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Send Break
      0  #0  Normal transmitter operation.
      1  #1  Queue break character(s) to be sent.
    */
    alias SBK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Receiver Wakeup Control
      0  #0  Normal UART receiver operation.
      1  #1  UART receiver in standby waiting for wakeup condition.
    */
    alias RWU =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receiver Enable
      0  #0  Receiver off.
      1  #1  Receiver on.
    */
    alias RE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Transmitter Enable
      0  #0  Transmitter off.
      1  #1  Transmitter on.
    */
    alias TE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Idle Line Interrupt Enable for IDLE
      0  #0  Hardware interrupts from IDLE disabled; use polling.
      1  #1  Hardware interrupt requested when IDLE flag is 1.
    */
    alias ILIE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Receiver Interrupt Enable for RDRF
      0  #0  Hardware interrupts from RDRF disabled; use polling.
      1  #1  Hardware interrupt requested when RDRF flag is 1.
    */
    alias RIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmission Complete Interrupt Enable for TC
      0  #0  Hardware interrupts from TC disabled; use polling.
      1  #1  Hardware interrupt requested when TC flag is 1.
    */
    alias TCIE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Transmit Interrupt Enable for TDRE
      0  #0  Hardware interrupts from TDRE disabled; use polling.
      1  #1  Hardware interrupt requested when TDRE flag is 1.
    */
    alias TIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Status Register 1
  */
  final abstract class S1  : Register!(0x4  , Access.read_only8)
  {
    /************************************************************************************
    Parity Error Flag
      0  #0  No parity error.
      1  #1  Parity error.
    */
    alias PF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Framing Error Flag
      0  #0  No framing error detected. This does not guarantee the framing is correct.
      1  #1  Framing error.
    */
    alias FE =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Noise Flag
      0  #0  No noise detected.
      1  #1  Noise detected in the received character in UART_D.
    */
    alias NF =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Receiver Overrun Flag
      0  #0  No overrun.
      1  #1  Receive overrun (new UART data lost).
    */
    alias OR =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Idle Line Flag
      0  #0  No idle line detected.
      1  #1  Idle line was detected.
    */
    alias IDLE =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    Receive Data Register Full Flag
      0  #0  Receive data register empty.
      1  #1  Receive data register full.
    */
    alias RDRF =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Transmission Complete Flag
      0  #0  Transmitter active (sending data, a preamble, or a break).
      1  #1  Transmitter idle (transmission activity complete).
    */
    alias TC =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Transmit Data Register Empty Flag
      0  #0  Transmit data register (buffer) full.
      1  #1  Transmit data register (buffer) empty.
    */
    alias TDRE =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * UART Status Register 2
  */
  final abstract class S2  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Receiver Active Flag
      0  #0  UART receiver idle waiting for a start bit.
      1  #1  UART receiver active (RxD input not idle).
    */
    alias RAF =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    LIN Break Detection Enable
      0  #0  Break character is detected at length 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1).
      1  #1  Break character is detected at length of 11 bit times (if M = 0, SBNS = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 13 (if M = 1, SBNS = 1).
    */
    alias LBKDE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Break Character Generation Length
      0  #0  Break character is transmitted with length of 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1).
      1  #1  Break character is transmitted with length of 13 bit times (if M = 0, SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1, SBNS = 1).
    */
    alias BRK13 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Receive Wake Up Idle Detect
      0  #0  During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character.
      1  #1  During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character.
    */
    alias RWUID =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Receive Data Inversion
      0  #0  Receive data not inverted.
      1  #1  Receive data inverted.
    */
    alias RXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    RxD Pin Active Edge Interrupt Flag
      0  #0  No active edge on the receive pin has occurred.
      1  #1  An active edge on the receive pin has occurred.
    */
    alias RXEDGIF =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    LIN Break Detect Interrupt Flag
      0  #0  No LIN break character has been detected.
      1  #1  LIN break character has been detected.
    */
    alias LBKDIF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 3
  */
  final abstract class C3  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    Parity Error Interrupt Enable
      0  #0  PF interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when PF is set.
    */
    alias PEIE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Framing Error Interrupt Enable
      0  #0  FE interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when FE is set.
    */
    alias FEIE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Noise Error Interrupt Enable
      0  #0  NF interrupts disabled; use polling).
      1  #1  Hardware interrupt requested when NF is set.
    */
    alias NEIE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Overrun Interrupt Enable
      0  #0  OR interrupts disabled; use polling.
      1  #1  Hardware interrupt requested when OR is set.
    */
    alias ORIE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Transmit Data Inversion
      0  #0  Transmit data not inverted.
      1  #1  Transmit data inverted.
    */
    alias TXINV =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    TxD Pin Direction in Single-Wire Mode
      0  #0  TxD pin is an input in single-wire mode.
      1  #1  TxD pin is an output in single-wire mode.
    */
    alias TXDIR =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Ninth Data Bit for Transmitter
    */
    alias T8 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Ninth Data Bit for Receiver
    */
    alias R8 =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * UART Data Register
  */
  final abstract class D  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias R0T0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R1T1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R2T2 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R3T3 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R4T4 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R5T5 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R6T6 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias R7T7 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * UART Control Register 4
  */
  final abstract class C4  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    Receiver Full DMA Select
      0  #0  If RIE is set and the RDRF flag is set, the RDRF interrupt request signal is asserted to request interrupt service.
      1  #1  If RIE is set and the RDRF flag is set, the RDRF DMA request signal is asserted to request a DMA transfer.
    */
    alias RDMAS =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Transmitter DMA Select
      0  #0  If TIE is set and the TDRE flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
      1  #1  If TIE is set and the TDRE flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.
    */
    alias TDMAS =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Universal Serial Bus, OTG Capable Controller
*/
final abstract class USB0: Peripheral!(0x40072000)
{
  /**************************************************************************************
  * Peripheral ID register
  */
  final abstract class PERID  : Register!(0  , Access.read_only8)
  {
    /************************************************************************************
    Peripheral Identification
    */
    alias ID =   BitField!(6, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Complement register
  */
  final abstract class IDCOMP  : Register!(0x4  , Access.read_only8)
  {
    /************************************************************************************
    no description available
    */
    alias NID =   BitField!(6, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral Revision register
  */
  final abstract class REV  : Register!(0x8  , Access.read_only8)
  {
    /************************************************************************************
    Revision
    */
    alias REV =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral Additional Info register
  */
  final abstract class ADDINFO  : Register!(0xC  , Access.read_only8)
  {
    /************************************************************************************
    no description available
    */
    alias IEHOST =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Assigned Interrupt Request Number
    */
    alias IRQNUM =   BitField!(8, 3, Mutability.read_only);

  }
  /**************************************************************************************
  * OTG Interrupt Status register
  */
  final abstract class OTGISTAT  : Register!(0x10  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias AVBUSCHG =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias B_SESS_CHG =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias SESSVLDCHG =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias LINE_STATE_CHG =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias ONEMSEC =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias IDCHG =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * OTG Interrupt Control Register
  */
  final abstract class OTGICR  : Register!(0x14  , Access.read_write8)
  {
    /************************************************************************************
    A VBUS Valid Interrupt Enable
      0  #0  Disables the AVBUSCHG interrupt.
      1  #1  Enables the AVBUSCHG interrupt.
    */
    alias AVBUSEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    B Session END Interrupt Enable
      0  #0  Disables the B_SESS_CHG interrupt.
      1  #1  Enables the B_SESS_CHG interrupt.
    */
    alias BSESSEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Session Valid Interrupt Enable
      0  #0  Disables the SESSVLDCHG interrupt.
      1  #1  Enables the SESSVLDCHG interrupt.
    */
    alias SESSVLDEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Line State Change Interrupt Enable
      0  #0  Disables the LINE_STAT_CHG interrupt.
      1  #1  Enables the LINE_STAT_CHG interrupt.
    */
    alias LINESTATEEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    One Millisecond Interrupt Enable
      0  #0  Diables the 1ms timer interrupt.
      1  #1  Enables the 1ms timer interrupt.
    */
    alias ONEMSECEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    ID Interrupt Enable
      0  #0  The ID interrupt is disabled
      1  #1  The ID interrupt is enabled
    */
    alias IDEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * OTG Status register
  */
  final abstract class OTGSTAT  : Register!(0x18  , Access.read_write8)
  {
    /************************************************************************************
    A VBUS Valid
      0  #0  The VBUS voltage is below the A VBUS Valid threshold.
      1  #1  The VBUS voltage is above the A VBUS Valid threshold.
    */
    alias AVBUSVLD =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    B Session End
      0  #0  The VBUS voltage is above the B session end threshold.
      1  #1  The VBUS voltage is below the B session end threshold.
    */
    alias BSESSEND =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Session Valid
      0  #0  The VBUS voltage is below the B session valid threshold
      1  #1  The VBUS voltage is above the B session valid threshold.
    */
    alias SESS_VLD =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
      0  #0  The LINE_STAT_CHG bit is not yet stable.
      1  #1  The LINE_STAT_CHG bit has been debounced and is stable.
    */
    alias LINESTATESTABLE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias ONEMSECEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
      0  #0  Indicates a Type A cable is plugged into the USB connector.
      1  #1  Indicates no cable is attached or a Type B cable is plugged into the USB connector.
    */
    alias ID =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * OTG Control register
  */
  final abstract class OTGCTL  : Register!(0x1C  , Access.read_write8)
  {
    /************************************************************************************
    On-The-Go pullup/pulldown resistor enable
      0  #0  If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+ and D- Data Line pull-down resistors are engaged.
      1  #1  The pull-up and pull-down controls in this register are used.
    */
    alias OTGEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    D- Data Line pull-down resistor enable
      0  #0  D- pulldown resistor is not enabled.
      1  #1  D- pulldown resistor is enabled.
    */
    alias DMLOW =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    D+ Data Line pull-down resistor enable
      0  #0  D+ pulldown resistor is not enabled.
      1  #1  D+ pulldown resistor is enabled.
    */
    alias DPLOW =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    D+ Data Line pullup resistor enable
      0  #0  D+ pullup resistor is not enabled
      1  #1  D+ pullup resistor is enabled
    */
    alias DPHIGH =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Interrupt Status register
  */
  final abstract class ISTAT  : Register!(0x80  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias USBRST =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias ERROR =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias SOFTOK =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias TOKDNE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias SLEEP =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RESUME =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Attach Interrupt
    */
    alias ATTACH =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Stall Interrupt
    */
    alias STALL =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Interrupt Enable register
  */
  final abstract class INTEN  : Register!(0x84  , Access.read_write8)
  {
    /************************************************************************************
    USBRST Interrupt Enable
      0  #0  Disables the USBRST interrupt.
      1  #1  Enables the USBRST interrupt.
    */
    alias USBRSTEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    ERROR Interrupt Enable
      0  #0  Disables the ERROR interrupt.
      1  #1  Enables the ERROR interrupt.
    */
    alias ERROREN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    SOFTOK Interrupt Enable
      0  #0  Disbles the SOFTOK interrupt.
      1  #1  Enables the SOFTOK interrupt.
    */
    alias SOFTOKEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    TOKDNE Interrupt Enable
      0  #0  Disables the TOKDNE interrupt.
      1  #1  Enables the TOKDNE interrupt.
    */
    alias TOKDNEEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    SLEEP Interrupt Enable
      0  #0  Disables the SLEEP interrupt.
      1  #1  Enables the SLEEP interrupt.
    */
    alias SLEEPEN =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    RESUME Interrupt Enable
      0  #0  Disables the RESUME interrupt.
      1  #1  Enables the RESUME interrupt.
    */
    alias RESUMEEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    ATTACH Interrupt Enable
      0  #0  Disables the ATTACH interrupt.
      1  #1  Enables the ATTACH interrupt.
    */
    alias ATTACHEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    STALL Interrupt Enable
      0  #0  Diasbles the STALL interrupt.
      1  #1  Enables the STALL interrupt.
    */
    alias STALLEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Error Interrupt Status register
  */
  final abstract class ERRSTAT  : Register!(0x88  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias PIDERR =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias CRC5EOF =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias CRC16 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias DFN8 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias BTOERR =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias DMAERR =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias BTSERR =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Error Interrupt Enable register
  */
  final abstract class ERREN  : Register!(0x8C  , Access.read_write8)
  {
    /************************************************************************************
    PIDERR Interrupt Enable
      0  #0  Disables the PIDERR interrupt.
      1  #1  Enters the PIDERR interrupt.
    */
    alias PIDERREN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    CRC5/EOF Interrupt Enable
      0  #0  Disables the CRC5/EOF interrupt.
      1  #1  Enables the CRC5/EOF interrupt.
    */
    alias CRC5EOFEN =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    CRC16 Interrupt Enable
      0  #0  Disables the CRC16 interrupt.
      1  #1  Enables the CRC16 interrupt.
    */
    alias CRC16EN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    DFN8 Interrupt Enable
      0  #0  Disables the DFN8 interrupt.
      1  #1  Enables the DFN8 interrupt.
    */
    alias DFN8EN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    BTOERR Interrupt Enable
      0  #0  Disables the BTOERR interrupt.
      1  #1  Enables the BTOERR interrupt.
    */
    alias BTOERREN =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    DMAERR Interrupt Enable
      0  #0  Disables the DMAERR interrupt.
      1  #1  Enables the DMAERR interrupt.
    */
    alias DMAERREN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    BTSERR Interrupt Enable
      0  #0  Disables the BTSERR interrupt.
      1  #1  Enables the BTSERR interrupt.
    */
    alias BTSERREN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Status register
  */
  final abstract class STAT  : Register!(0x90  , Access.read_only8)
  {
    /************************************************************************************
    no description available
    */
    alias ODD =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Transmit Indicator
      0  #0  The most recent transaction was a receive operation.
      1  #1  The most recent transaction was a transmit operation.
    */
    alias TX =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    no description available
    */
    alias ENDP =   BitField!(8, 4, Mutability.read_only);

  }
  /**************************************************************************************
  * Control register
  */
  final abstract class CTL  : Register!(0x94  , Access.read_write8)
  {
    /************************************************************************************
    USB Enable
      0  #0  Disables the USB Module.
      1  #1  Enables the USB Module.
    */
    alias USBENSOFEN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias ODDRST =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RESUME =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTMODEEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RESET =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias TXSUSPENDTOKENBUSY =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Live USB Single Ended Zero signal
    */
    alias SE0 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Live USB differential receiver JSTATE signal
    */
    alias JSTATE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Address register
  */
  final abstract class ADDR  : Register!(0x98  , Access.read_write8)
  {
    /************************************************************************************
    USB Address
    */
    alias ADDR =   BitField!(7, 0, Mutability.read_write);

    /************************************************************************************
    Low Speed Enable bit
    */
    alias LSEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * BDT Page Register 1
  */
  final abstract class BDTPAGE1  : Register!(0x9C  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias BDTBA =   BitField!(8, 1, Mutability.read_write);

  }
  /**************************************************************************************
  * Frame Number Register Low
  */
  final abstract class FRMNUML  : Register!(0xA0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias FRM =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Frame Number Register High
  */
  final abstract class FRMNUMH  : Register!(0xA4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias FRM =   BitField!(3, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Token register
  */
  final abstract class TOKEN  : Register!(0xA8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias TOKENENDPT =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    no description available
      0001  #0001  OUT Token. USB Module performs an OUT (TX) transaction.
      1001  #1001  IN Token. USB Module performs an In (RX) transaction.
      1101  #1101  SETUP Token. USB Module performs a SETUP (TX) transaction
    */
    alias TOKENPID =   BitField!(8, 4, Mutability.read_write);

  }
  /**************************************************************************************
  * SOF Threshold Register
  */
  final abstract class SOFTHLD  : Register!(0xAC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias CNT =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * BDT Page Register 2
  */
  final abstract class BDTPAGE2  : Register!(0xB0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias BDTBA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * BDT Page Register 3
  */
  final abstract class BDTPAGE3  : Register!(0xB4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias BDTBA =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT0  : Register!(0XC0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT1  : Register!(0XC4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT2  : Register!(0XC8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT3  : Register!(0XCC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT4  : Register!(0XD0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT5  : Register!(0XD4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT6  : Register!(0XD8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT7  : Register!(0XDC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT8  : Register!(0XE0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT9  : Register!(0XE4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT10  : Register!(0XE8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT11  : Register!(0XEC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT12  : Register!(0XF0  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT13  : Register!(0XF4  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT14  : Register!(0XF8  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * Endpoint Control register
  */
  final abstract class ENDPT15  : Register!(0XFC  , Access.read_write8)
  {
    /************************************************************************************
    no description available
    */
    alias EPHSHK =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPSTALL =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPTXEN =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPRXEN =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias EPCTLDIS =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias RETRYDIS =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias HOSTWOHUB =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * USB Control register
  */
  final abstract class USBCTRL  : Register!(0x100  , Access.read_write8)
  {
    /************************************************************************************
    no description available
      0  #0  Weak pulldowns are disabled on D+ and D-.
      1  #1  Weak pulldowns are enabled on D+ and D-.
    */
    alias PDE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    no description available
      0  #0  USB transceiver is not in suspend state.
      1  #1  USB transceiver is in suspend state.
    */
    alias SUSP =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * USB OTG Observe register
  */
  final abstract class OBSERVE  : Register!(0x104  , Access.read_only8)
  {
    /************************************************************************************
    no description available
      0  #0  D- pulldown disabled.
      1  #1  D- pulldown enabled.
    */
    alias DMPD =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    no description available
      0  #0  D+ pulldown disabled.
      1  #1  D+ pulldown enabled.
    */
    alias DPPD =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    no description available
      0  #0  D+ pullup disabled.
      1  #1  D+ pullup enabled.
    */
    alias DPPU =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * USB OTG Control register
  */
  final abstract class CONTROL  : Register!(0x108  , Access.read_write8)
  {
    /************************************************************************************
    no description available
      0  #0  DP Pullup in non-OTG device mode is not enabled.
      1  #1  DP Pullup in non-OTG device mode is enabled.
    */
    alias DPPULLUPNONOTG =   Bit!(5, Mutability.read_write);

  }
  /**************************************************************************************
  * USB Transceiver Control Register 0
  */
  final abstract class USBTRC0  : Register!(0x10C  , Access.read_write8)
  {
    /************************************************************************************
    USB Asynchronous Interrupt
      0  #0  No interrupt was generated.
      1  #1  Interrupt was generated because of the USB asynchronous interrupt.
    */
    alias USB_RESUME_INT =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Synchronous USB Interrupt Detect
      0  #0  Synchronous interrupt has not been detected.
      1  #1  Synchronous interrupt has been detected.
    */
    alias SYNC_DET =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Asynchronous Resume Interrupt Enable
      0  #0  USB asynchronous wakeup from suspend mode disabled.
      1  #1  USB asynchronous wakeup from suspend mode enabled. The asynchronous resume interrupt differs from the synchronous resume interrupt in that it asynchronously detects K-state using the unfiltered state of the D+ and D- pins. This interupt should only be enabled when the Transceiver is suspended.
    */
    alias USBRESMEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    USB Reset
      0  #0  Normal USB module operation.
      1  #1  Returns the USB module to its reset state.
    */
    alias USBRESET =   Bit!(8, Mutability.write_only);

  }
  /**************************************************************************************
  * Frame Adjust Register
  */
  final abstract class USBFRMADJUST  : Register!(0x114  , Access.read_write8)
  {
    /************************************************************************************
    Frame Adjustment
    */
    alias ADJ =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
*/
final abstract class CMP0: Peripheral!(0x40073000)
{
  /**************************************************************************************
  * CMP Control Register 0
  */
  final abstract class CR0  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Comparator hard block hysteresis control
      00  #00  Level 0
      01  #01  Level 1
      10  #10  Level 2
      11  #11  Level 3
    */
    alias HYSTCTR =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Filter Sample Count
      000  #000  Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
      001  #001  One sample must agree. The comparator output is simply sampled.
      010  #010  2 consecutive samples must agree.
      011  #011  3 consecutive samples must agree.
      100  #100  4 consecutive samples must agree.
      101  #101  5 consecutive samples must agree.
      110  #110  6 consecutive samples must agree.
      111  #111  7 consecutive samples must agree.
    */
    alias FILTER_CNT =   BitField!(7, 4, Mutability.read_write);

  }
  /**************************************************************************************
  * CMP Control Register 1
  */
  final abstract class CR1  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Comparator Module Enable
      0  #0  Analog Comparator is disabled.
      1  #1  Analog Comparator is enabled.
    */
    alias EN =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Comparator Output Pin Enable
      0  #0  CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
      1  #1  CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.
    */
    alias OPE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Comparator Output Select
      0  #0  Set the filtered comparator output (CMPO) to equal COUT.
      1  #1  Set the unfiltered comparator output (CMPO) to equal COUTA.
    */
    alias COS =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Comparator INVERT
      0  #0  Does not invert the comparator output.
      1  #1  Inverts the comparator output.
    */
    alias INV =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Power Mode Select
      0  #0  Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
      1  #1  High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.
    */
    alias PMODE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Trigger Mode Enable
      0  #0  Trigger mode is disabled.
      1  #1  Trigger mode is enabled.
    */
    alias TRIGM =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Windowing Enable
      0  #0  Windowing mode is not selected.
      1  #1  Windowing mode is selected.
    */
    alias WE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Sample Enable
      0  #0  Sampling mode is not selected.
      1  #1  Sampling mode is selected.
    */
    alias SE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * CMP Filter Period Register
  */
  final abstract class FPR  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Filter Sample Period
    */
    alias FILT_PER =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * CMP Status and Control Register
  */
  final abstract class SCR  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Analog Comparator Output
    */
    alias COUT =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Analog Comparator Flag Falling
      0  #0  Falling-edge on COUT has not been detected.
      1  #1  Falling-edge on COUT has occurred.
    */
    alias CFF =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Analog Comparator Flag Rising
      0  #0  Rising-edge on COUT has not been detected.
      1  #1  Rising-edge on COUT has occurred.
    */
    alias CFR =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Comparator Interrupt Enable Falling
      0  #0  Interrupt is disabled.
      1  #1  Interrupt is enabled.
    */
    alias IEF =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Comparator Interrupt Enable Rising
      0  #0  Interrupt is disabled.
      1  #1  Interrupt is enabled.
    */
    alias IER =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    DMA Enable Control
      0  #0  DMA is disabled.
      1  #1  DMA is enabled.
    */
    alias DMAEN =   Bit!(7, Mutability.read_write);

  }
  /**************************************************************************************
  * DAC Control Register
  */
  final abstract class DACCR  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    DAC Output Voltage Select
    */
    alias VOSEL =   BitField!(6, 0, Mutability.read_write);

    /************************************************************************************
    Supply Voltage Reference Source Select
      0  #0  V is selected as resistor ladder network supply reference V. in1 in
      1  #1  V is selected as resistor ladder network supply reference V. in2 in
    */
    alias VRSEL =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    DAC Enable
      0  #0  DAC is disabled.
      1  #1  DAC is enabled.
    */
    alias DACEN =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * MUX Control Register
  */
  final abstract class MUXCR  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Minus Input Mux Control
      000  #000  IN0
      001  #001  IN1
      010  #010  IN2
      011  #011  IN3
      100  #100  IN4
      101  #101  IN5
      110  #110  IN6
      111  #111  IN7
    */
    alias MSEL =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Plus Input Mux Control
      000  #000  IN0
      001  #001  IN1
      010  #010  IN2
      011  #011  IN3
      100  #100  IN4
      101  #101  IN5
      110  #110  IN6
      111  #111  IN7
    */
    alias PSEL =   BitField!(6, 3, Mutability.read_write);

    /************************************************************************************
    Pass Through Mode Enable
      0  #0  Pass Through Mode is disabled.
      1  #1  Pass Through Mode is enabled.
    */
    alias PSTM =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Serial Peripheral Interface
*/
final abstract class SPI0: Peripheral!(0x40076000)
{
  /**************************************************************************************
  * SPI control register 1
  */
  final abstract class C1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    LSB first (shifter direction)
      0  #0  SPI serial data transfers start with most significant bit
      1  #1  SPI serial data transfers start with least significant bit
    */
    alias LSBFE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Slave select output enable
      0  #0  When MODFEN is 0: In master mode, SS pin function is general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input. When MODFEN is 1: In master mode, SS pin function is SS input for mode fault. In slave mode, SS pin function is slave select input.
      1  #1  When MODFEN is 0: In master mode, SS pin function is general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input. When MODFEN is 1: In master mode, SS pin function is automatic SS output. In slave mode: SS pin function is slave select input.
    */
    alias SSOE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Clock phase
      0  #0  First edge on SPSCK occurs at the middle of the first cycle of a data transfer
      1  #1  First edge on SPSCK occurs at the start of the first cycle of a data transfer
    */
    alias CPHA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Clock polarity
      0  #0  Active-high SPI clock (idles low)
      1  #1  Active-low SPI clock (idles high)
    */
    alias CPOL =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Master/slave mode select
      0  #0  SPI module configured as a slave SPI device
      1  #1  SPI module configured as a master SPI device
    */
    alias MSTR =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    SPI transmit interrupt enable
      0  #0  Interrupts from SPTEF inhibited (use polling)
      1  #1  When SPTEF is 1, hardware interrupt requested
    */
    alias SPTIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SPI system enable
      0  #0  SPI system inactive
      1  #1  SPI system enabled
    */
    alias SPE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    SPI interrupt enable: for SPRF and MODF
      0  #0  Interrupts from SPRF and MODF are inhibited-use polling
      1  #1  Request a hardware interrupt when SPRF or MODF is 1
    */
    alias SPIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI control register 2
  */
  final abstract class C2  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    SPI pin control 0
      0  #0  SPI uses separate pins for data input and data output (pin mode is normal). In master mode of operation: MISO is master in and MOSI is master out. In slave mode of operation: MISO is slave out and MOSI is slave in.
      1  #1  SPI configured for single-wire bidirectional operation (pin mode is bidirectional). In master mode of operation: MISO is not used by SPI; MOSI is master in when BIDIROE is 0 or master I/O when BIDIROE is 1. In slave mode of operation: MISO is slave in when BIDIROE is 0 or slave I/O when BIDIROE is 1; MOSI is not used by SPI.
    */
    alias SPC0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    SPI stop in wait mode
      0  #0  SPI clocks continue to operate in wait mode
      1  #1  SPI clocks stop when the MCU enters wait mode
    */
    alias SPISWAI =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receive DMA enable
      0  #0  DMA request for receive is disabled and interrupt from SPRF is allowed
      1  #1  DMA request for receive is enabled and interrupt from SPRF is disabled
    */
    alias RXDMAE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Bidirectional mode output enable
      0  #0  Output driver disabled so SPI data I/O pin acts as an input
      1  #1  SPI I/O pin enabled as an output
    */
    alias BIDIROE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Master mode-fault function enable
      0  #0  Mode fault function disabled, master SS pin reverts to general-purpose I/O not controlled by SPI
      1  #1  Mode fault function enabled, master SS pin acts as the mode fault input or the slave select output
    */
    alias MODFEN =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Transmit DMA enable
      0  #0  DMA request for transmit is disabled and interrupt from SPTEF is allowed
      1  #1  DMA request for transmit is enabled and interrupt from SPTEF is disabled
    */
    alias TXDMAE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SPI match interrupt enable
      0  #0  Interrupts from SPMF inhibited (use polling)
      1  #1  When SPMF is 1, requests a hardware interrupt
    */
    alias SPMIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI baud rate register
  */
  final abstract class BR  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    SPI baud rate divisor
      0000  #0000  Baud rate divisor is 2
      0001  #0001  Baud rate divisor is 4
      0010  #0010  Baud rate divisor is 8
      0011  #0011  Baud rate divisor is 16
      0100  #0100  Baud rate divisor is 32
      0101  #0101  Baud rate divisor is 64
      0110  #0110  Baud rate divisor is 128
      0111  #0111  Baud rate divisor is 256
      1000  #1000  Baud rate divisor is 512
    */
    alias SPR =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    SPI baud rate prescale divisor
      000  #000  Baud rate prescaler divisor is 1
      001  #001  Baud rate prescaler divisor is 2
      010  #010  Baud rate prescaler divisor is 3
      011  #011  Baud rate prescaler divisor is 4
      100  #100  Baud rate prescaler divisor is 5
      101  #101  Baud rate prescaler divisor is 6
      110  #110  Baud rate prescaler divisor is 7
      111  #111  Baud rate prescaler divisor is 8
    */
    alias SPPR =   BitField!(7, 4, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI status register
  */
  final abstract class S  : Register!(0x3  , Access.read_only8)
  {
    /************************************************************************************
    Master mode fault flag
      0  #0  No mode fault error
      1  #1  Mode fault error detected
    */
    alias MODF =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    SPI transmit buffer empty flag
      0  #0  SPI transmit buffer not empty
      1  #1  SPI transmit buffer empty
    */
    alias SPTEF =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    SPI match flag
      0  #0  Value in the receive data buffer does not match the value in the M register
      1  #1  Value in the receive data buffer matches the value in the M register
    */
    alias SPMF =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    SPI read buffer full flag
      0  #0  No data available in the receive data buffer
      1  #1  Data available in the receive data buffer
    */
    alias SPRF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * SPI data register
  */
  final abstract class D  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Data (low byte)
    */
    alias Bits =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI match register
  */
  final abstract class M  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    Hardware compare value (low byte)
    */
    alias Bits =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Serial Peripheral Interface
*/
final abstract class SPI1: Peripheral!(0x40077000)
{
  /**************************************************************************************
  * SPI control register 1
  */
  final abstract class C1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    LSB first (shifter direction)
      0  #0  SPI serial data transfers start with most significant bit
      1  #1  SPI serial data transfers start with least significant bit
    */
    alias LSBFE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Slave select output enable
      0  #0  When MODFEN is 0: In master mode, SS pin function is general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input. When MODFEN is 1: In master mode, SS pin function is SS input for mode fault. In slave mode, SS pin function is slave select input.
      1  #1  When MODFEN is 0: In master mode, SS pin function is general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input. When MODFEN is 1: In master mode, SS pin function is automatic SS output. In slave mode: SS pin function is slave select input.
    */
    alias SSOE =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Clock phase
      0  #0  First edge on SPSCK occurs at the middle of the first cycle of a data transfer
      1  #1  First edge on SPSCK occurs at the start of the first cycle of a data transfer
    */
    alias CPHA =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Clock polarity
      0  #0  Active-high SPI clock (idles low)
      1  #1  Active-low SPI clock (idles high)
    */
    alias CPOL =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Master/slave mode select
      0  #0  SPI module configured as a slave SPI device
      1  #1  SPI module configured as a master SPI device
    */
    alias MSTR =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    SPI transmit interrupt enable
      0  #0  Interrupts from SPTEF inhibited (use polling)
      1  #1  When SPTEF is 1, hardware interrupt requested
    */
    alias SPTIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SPI system enable
      0  #0  SPI system inactive
      1  #1  SPI system enabled
    */
    alias SPE =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    SPI interrupt enable: for SPRF and MODF
      0  #0  Interrupts from SPRF and MODF are inhibited-use polling
      1  #1  Request a hardware interrupt when SPRF or MODF is 1
    */
    alias SPIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI control register 2
  */
  final abstract class C2  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    SPI pin control 0
      0  #0  SPI uses separate pins for data input and data output (pin mode is normal). In master mode of operation: MISO is master in and MOSI is master out. In slave mode of operation: MISO is slave out and MOSI is slave in.
      1  #1  SPI configured for single-wire bidirectional operation (pin mode is bidirectional). In master mode of operation: MISO is not used by SPI; MOSI is master in when BIDIROE is 0 or master I/O when BIDIROE is 1. In slave mode of operation: MISO is slave in when BIDIROE is 0 or slave I/O when BIDIROE is 1; MOSI is not used by SPI.
    */
    alias SPC0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    SPI stop in wait mode
      0  #0  SPI clocks continue to operate in wait mode
      1  #1  SPI clocks stop when the MCU enters wait mode
    */
    alias SPISWAI =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Receive DMA enable
      0  #0  DMA request for receive is disabled and interrupt from SPRF is allowed
      1  #1  DMA request for receive is enabled and interrupt from SPRF is disabled
    */
    alias RXDMAE =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Bidirectional mode output enable
      0  #0  Output driver disabled so SPI data I/O pin acts as an input
      1  #1  SPI I/O pin enabled as an output
    */
    alias BIDIROE =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Master mode-fault function enable
      0  #0  Mode fault function disabled, master SS pin reverts to general-purpose I/O not controlled by SPI
      1  #1  Mode fault function enabled, master SS pin acts as the mode fault input or the slave select output
    */
    alias MODFEN =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Transmit DMA enable
      0  #0  DMA request for transmit is disabled and interrupt from SPTEF is allowed
      1  #1  DMA request for transmit is enabled and interrupt from SPTEF is disabled
    */
    alias TXDMAE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    SPI match interrupt enable
      0  #0  Interrupts from SPMF inhibited (use polling)
      1  #1  When SPMF is 1, requests a hardware interrupt
    */
    alias SPMIE =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI baud rate register
  */
  final abstract class BR  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    SPI baud rate divisor
      0000  #0000  Baud rate divisor is 2
      0001  #0001  Baud rate divisor is 4
      0010  #0010  Baud rate divisor is 8
      0011  #0011  Baud rate divisor is 16
      0100  #0100  Baud rate divisor is 32
      0101  #0101  Baud rate divisor is 64
      0110  #0110  Baud rate divisor is 128
      0111  #0111  Baud rate divisor is 256
      1000  #1000  Baud rate divisor is 512
    */
    alias SPR =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    SPI baud rate prescale divisor
      000  #000  Baud rate prescaler divisor is 1
      001  #001  Baud rate prescaler divisor is 2
      010  #010  Baud rate prescaler divisor is 3
      011  #011  Baud rate prescaler divisor is 4
      100  #100  Baud rate prescaler divisor is 5
      101  #101  Baud rate prescaler divisor is 6
      110  #110  Baud rate prescaler divisor is 7
      111  #111  Baud rate prescaler divisor is 8
    */
    alias SPPR =   BitField!(7, 4, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI status register
  */
  final abstract class S  : Register!(0x3  , Access.read_only8)
  {
    /************************************************************************************
    Master mode fault flag
      0  #0  No mode fault error
      1  #1  Mode fault error detected
    */
    alias MODF =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    SPI transmit buffer empty flag
      0  #0  SPI transmit buffer not empty
      1  #1  SPI transmit buffer empty
    */
    alias SPTEF =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    SPI match flag
      0  #0  Value in the receive data buffer does not match the value in the M register
      1  #1  Value in the receive data buffer matches the value in the M register
    */
    alias SPMF =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    SPI read buffer full flag
      0  #0  No data available in the receive data buffer
      1  #1  Data available in the receive data buffer
    */
    alias SPRF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * SPI data register
  */
  final abstract class D  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Data (low byte)
    */
    alias Bits =   BitField!(8, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * SPI match register
  */
  final abstract class M  : Register!(0x7  , Access.read_write8)
  {
    /************************************************************************************
    Hardware compare value (low byte)
    */
    alias Bits =   BitField!(8, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Low leakage wakeup unit
*/
final abstract class LLWU: Peripheral!(0x4007C000)
{
  /**************************************************************************************
  * LLWU Pin Enable 1 register
  */
  final abstract class PE1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Pin Enable For LLWU_P0
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE0 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P1
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE1 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P2
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE2 =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P3
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE3 =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Pin Enable 2 register
  */
  final abstract class PE2  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Pin Enable For LLWU_P4
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE4 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P5
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE5 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P6
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE6 =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P7
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE7 =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Pin Enable 3 register
  */
  final abstract class PE3  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Pin Enable For LLWU_P8
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE8 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P9
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE9 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P10
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE10 =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P11
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE11 =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Pin Enable 4 register
  */
  final abstract class PE4  : Register!(0x3  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Pin Enable For LLWU_P12
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE12 =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P13
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE13 =   BitField!(4, 2, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P14
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE14 =   BitField!(6, 4, Mutability.read_write);

    /************************************************************************************
    Wakeup Pin Enable For LLWU_P15
      00  #00  External input pin disabled as wakeup input
      01  #01  External input pin enabled with rising edge detection
      10  #10  External input pin enabled with falling edge detection
      11  #11  External input pin enabled with any change detection
    */
    alias WUPE15 =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Module Enable register
  */
  final abstract class ME  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Module Enable For Module 0
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable for Module 1
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 2
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME2 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 3
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME3 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 4
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME4 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 5
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME5 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 6
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME6 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Wakeup Module Enable For Module 7
      0  #0  Internal module flag not used as wakeup source
      1  #1  Internal module flag used as wakeup source
    */
    alias WUME7 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Flag 1 register
  */
  final abstract class F1  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Flag For LLWU_P0
      0  #0  LLWU_P0 input was not a wakeup source
      1  #1  LLWU_P0 input was a wakeup source
    */
    alias WUF0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P1
      0  #0  LLWU_P1 input was not a wakeup source
      1  #1  LLWU_P1 input was a wakeup source
    */
    alias WUF1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P2
      0  #0  LLWU_P2 input was not a wakeup source
      1  #1  LLWU_P2 input was a wakeup source
    */
    alias WUF2 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P3
      0  #0  LLWU_P3 input was not a wakeup source
      1  #1  LLWU_P3 input was a wakeup source
    */
    alias WUF3 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P4
      0  #0  LLWU_P4 input was not a wakeup source
      1  #1  LLWU_P4 input was a wakeup source
    */
    alias WUF4 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P5
      0  #0  LLWU_P5 input was not a wakeup source
      1  #1  LLWU_P5 input was a wakeup source
    */
    alias WUF5 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P6
      0  #0  LLWU_P6 input was not a wakeup source
      1  #1  LLWU_P6 input was a wakeup source
    */
    alias WUF6 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P7
      0  #0  LLWU_P7 input was not a wakeup source
      1  #1  LLWU_P7 input was a wakeup source
    */
    alias WUF7 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Flag 2 register
  */
  final abstract class F2  : Register!(0x6  , Access.read_write8)
  {
    /************************************************************************************
    Wakeup Flag For LLWU_P8
      0  #0  LLWU_P8 input was not a wakeup source
      1  #1  LLWU_P8 input was a wakeup source
    */
    alias WUF8 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P9
      0  #0  LLWU_P9 input was not a wakeup source
      1  #1  LLWU_P9 input was a wakeup source
    */
    alias WUF9 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P10
      0  #0  LLWU_P10 input was not a wakeup source
      1  #1  LLWU_P10 input was a wakeup source
    */
    alias WUF10 =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P11
      0  #0  LLWU_P11 input was not a wakeup source
      1  #1  LLWU_P11 input was a wakeup source
    */
    alias WUF11 =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P12
      0  #0  LLWU_P12 input was not a wakeup source
      1  #1  LLWU_P12 input was a wakeup source
    */
    alias WUF12 =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P13
      0  #0  LLWU_P13 input was not a wakeup source
      1  #1  LLWU_P13 input was a wakeup source
    */
    alias WUF13 =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P14
      0  #0  LLWU_P14 input was not a wakeup source
      1  #1  LLWU_P14 input was a wakeup source
    */
    alias WUF14 =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Wakeup Flag For LLWU_P15
      0  #0  LLWU_P15 input was not a wakeup source
      1  #1  LLWU_P15 input was a wakeup source
    */
    alias WUF15 =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Flag 3 register
  */
  final abstract class F3  : Register!(0x7  , Access.read_only8)
  {
    /************************************************************************************
    Wakeup flag For module 0
      0  #0  Module 0 input was not a wakeup source
      1  #1  Module 0 input was a wakeup source
    */
    alias MWUF0 =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 1
      0  #0  Module 1 input was not a wakeup source
      1  #1  Module 1 input was a wakeup source
    */
    alias MWUF1 =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 2
      0  #0  Module 2 input was not a wakeup source
      1  #1  Module 2 input was a wakeup source
    */
    alias MWUF2 =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 3
      0  #0  Module 3 input was not a wakeup source
      1  #1  Module 3 input was a wakeup source
    */
    alias MWUF3 =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 4
      0  #0  Module 4 input was not a wakeup source
      1  #1  Module 4 input was a wakeup source
    */
    alias MWUF4 =   Bit!(5, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 5
      0  #0  Module 5 input was not a wakeup source
      1  #1  Module 5 input was a wakeup source
    */
    alias MWUF5 =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 6
      0  #0  Module 6 input was not a wakeup source
      1  #1  Module 6 input was a wakeup source
    */
    alias MWUF6 =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Wakeup flag For module 7
      0  #0  Module 7 input was not a wakeup source
      1  #1  Module 7 input was a wakeup source
    */
    alias MWUF7 =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * LLWU Pin Filter 1 register
  */
  final abstract class FILT1  : Register!(0x8  , Access.read_write8)
  {
    /************************************************************************************
    Filter Pin Select
      0000  #0000  Select LLWU_P0 for filter
      1111  #1111  Select LLWU_P15 for filter
    */
    alias FILTSEL =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    Digital Filter On External Pin
      00  #00  Filter disabled
      01  #01  Filter posedge detect enabled
      10  #10  Filter negedge detect enabled
      11  #11  Filter any edge detect enabled
    */
    alias FILTE =   BitField!(7, 5, Mutability.read_write);

    /************************************************************************************
    Filter Detect Flag
      0  #0  Pin Filter 1 was not a wakeup source
      1  #1  Pin Filter 1 was a wakeup source
    */
    alias FILTF =   Bit!(8, Mutability.read_write);

  }
  /**************************************************************************************
  * LLWU Pin Filter 2 register
  */
  final abstract class FILT2  : Register!(0x9  , Access.read_write8)
  {
    /************************************************************************************
    Filter Pin Select
      0000  #0000  Select LLWU_P0 for filter
      1111  #1111  Select LLWU_P15 for filter
    */
    alias FILTSEL =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    Digital Filter On External Pin
      00  #00  Filter disabled
      01  #01  Filter posedge detect enabled
      10  #10  Filter negedge detect enabled
      11  #11  Filter any edge detect enabled
    */
    alias FILTE =   BitField!(7, 5, Mutability.read_write);

    /************************************************************************************
    Filter Detect Flag
      0  #0  Pin Filter 2 was not a wakeup source
      1  #1  Pin Filter 2 was a wakeup source
    */
    alias FILTF =   Bit!(8, Mutability.read_write);

  }
}
/****************************************************************************************
  * Power Management Controller
*/
final abstract class PMC: Peripheral!(0x4007D000)
{
  /**************************************************************************************
  * Low Voltage Detect Status And Control 1 register
  */
  final abstract class LVDSC1  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Low-Voltage Detect Voltage Select
      00  #00  Low trip point selected (V LVD = V LVDL )
      01  #01  High trip point selected (V LVD = V LVDH )
    */
    alias LVDV =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Low-Voltage Detect Reset Enable
      0  #0  LVDF does not generate hardware resets
      1  #1  Force an MCU reset when LVDF = 1
    */
    alias LVDRE =   Bit!(5, Mutability.read_write);

    /************************************************************************************
    Low-Voltage Detect Interrupt Enable
      0  #0  Hardware interrupt disabled (use polling)
      1  #1  Request a hardware interrupt when LVDF = 1
    */
    alias LVDIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Low-Voltage Detect Acknowledge
    */
    alias LVDACK =   Bit!(7, Mutability.write_only);

    /************************************************************************************
    Low-Voltage Detect Flag
      0  #0  Low-voltage event not detected
      1  #1  Low-voltage event detected
    */
    alias LVDF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * Low Voltage Detect Status And Control 2 register
  */
  final abstract class LVDSC2  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Low-Voltage Warning Voltage Select
      00  #00  Low trip point selected (VLVW = VLVW1)
      01  #01  Mid 1 trip point selected (VLVW = VLVW2)
      10  #10  Mid 2 trip point selected (VLVW = VLVW3)
      11  #11  High trip point selected (VLVW = VLVW4)
    */
    alias LVWV =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Low-Voltage Warning Interrupt Enable
      0  #0  Hardware interrupt disabled (use polling)
      1  #1  Request a hardware interrupt when LVWF = 1
    */
    alias LVWIE =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Low-Voltage Warning Acknowledge
    */
    alias LVWACK =   Bit!(7, Mutability.write_only);

    /************************************************************************************
    Low-Voltage Warning Flag
      0  #0  Low-voltage warning event not detected
      1  #1  Low-voltage warning event detected
    */
    alias LVWF =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * Regulator Status And Control register
  */
  final abstract class REGSC  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    Bandgap Buffer Enable
      0  #0  Bandgap buffer not enabled
      1  #1  Bandgap buffer enabled
    */
    alias BGBE =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Regulator In Run Regulation Status
      0  #0  Regulator is in stop regulation or in transition to/from it
      1  #1  Regulator is in run regulation
    */
    alias REGONS =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Acknowledge Isolation
      0  #0  Peripherals and I/O pads are in normal run state
      1  #1  Certain peripherals and I/O pads are in an isolated and latched state
    */
    alias ACKISO =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Bandgap Enable In VLPx Operation
      0  #0  Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes
      1  #1  Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes
    */
    alias BGEN =   Bit!(5, Mutability.read_write);

  }
}
/****************************************************************************************
  * System Mode Controller
*/
final abstract class SMC: Peripheral!(0x4007E000)
{
  /**************************************************************************************
  * Power Mode Protection register
  */
  final abstract class PMPROT  : Register!(0  , Access.read_write8)
  {
    /************************************************************************************
    Allow Very-Low-Leakage Stop Mode
      0  #0  Any VLLSx mode is not allowed
      1  #1  Any VLLSx mode is allowed
    */
    alias AVLLS =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Allow Low-Leakage Stop Mode
      0  #0  LLS is not allowed
      1  #1  LLS is allowed
    */
    alias ALLS =   Bit!(4, Mutability.read_write);

    /************************************************************************************
    Allow Very-Low-Power Modes
      0  #0  VLPR, VLPW and VLPS are not allowed
      1  #1  VLPR, VLPW and VLPS are allowed
    */
    alias AVLP =   Bit!(6, Mutability.read_write);

  }
  /**************************************************************************************
  * Power Mode Control register
  */
  final abstract class PMCTRL  : Register!(0x1  , Access.read_write8)
  {
    /************************************************************************************
    Stop Mode Control
      000  #000  Normal Stop (STOP)
      010  #010  Very-Low-Power Stop (VLPS)
      011  #011  Low-Leakage Stop (LLS)
      100  #100  Very-Low-Leakage Stop (VLLSx)
      110  #110  Reseved
    */
    alias STOPM =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    Stop Aborted
      0  #0  The previous stop mode entry was successsful.
      1  #1  The previous stop mode entry was aborted.
    */
    alias STOPA =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Run Mode Control
      00  #00  Normal Run mode (RUN)
      10  #10  Very-Low-Power Run mode (VLPR)
    */
    alias RUNM =   BitField!(7, 5, Mutability.read_write);

  }
  /**************************************************************************************
  * Stop Control Register
  */
  final abstract class STOPCTRL  : Register!(0x2  , Access.read_write8)
  {
    /************************************************************************************
    VLLS Mode Control.
      000  #000  VLLS0
      001  #001  VLLS1
      011  #011  VLLS3
    */
    alias VLLSM =   BitField!(3, 0, Mutability.read_write);

    /************************************************************************************
    POR Power Option
      0  #0  POR detect circuit is enabled in VLLS0
      1  #1  POR detect circuit is disabled in VLLS0
    */
    alias PORPO =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Partial Stop Option
      00  #00  STOP - Normal Stop mode
      01  #01  PSTOP1 - Partial Stop with both system and bus clocks disabled
      10  #10  PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
    */
    alias PSTOPO =   BitField!(8, 6, Mutability.read_write);

  }
  /**************************************************************************************
  * Power Mode Status register
  */
  final abstract class PMSTAT  : Register!(0x3  , Access.read_only8)
  {
    /************************************************************************************
    no description available
    */
    alias PMSTAT =   BitField!(7, 0, Mutability.read_only);

  }
}
/****************************************************************************************
  * Reset Control Module
*/
final abstract class RCM: Peripheral!(0x4007F000)
{
  /**************************************************************************************
  * System Reset Status Register 0
  */
  final abstract class SRS0  : Register!(0  , Access.read_only8)
  {
    /************************************************************************************
    Low Leakage Wakeup Reset
      0  #0  Reset not caused by LLWU module wakeup source
      1  #1  Reset caused by LLWU module wakeup source
    */
    alias WAKEUP =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    Low-Voltage Detect Reset
      0  #0  Reset not caused by LVD trip or POR
      1  #1  Reset caused by LVD trip or POR
    */
    alias LVD =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Loss-of-Clock Reset
      0  #0  Reset not caused by a loss of external clock.
      1  #1  Reset caused by a loss of external clock.
    */
    alias LOC =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    Loss-of-Lock Reset
      0  #0  Reset not caused by a loss of lock in the PLL
      1  #1  Reset caused by a loss of lock in the PLL
    */
    alias LOL =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Watchdog
      0  #0  Reset not caused by watchdog timeout
      1  #1  Reset caused by watchdog timeout
    */
    alias WDOG =   Bit!(6, Mutability.read_only);

    /************************************************************************************
    External Reset Pin
      0  #0  Reset not caused by external reset pin
      1  #1  Reset caused by external reset pin
    */
    alias PIN =   Bit!(7, Mutability.read_only);

    /************************************************************************************
    Power-On Reset
      0  #0  Reset not caused by POR
      1  #1  Reset caused by POR
    */
    alias POR =   Bit!(8, Mutability.read_only);

  }
  /**************************************************************************************
  * System Reset Status Register 1
  */
  final abstract class SRS1  : Register!(0x1  , Access.read_only8)
  {
    /************************************************************************************
    Core Lockup
      0  #0  Reset not caused by core LOCKUP event
      1  #1  Reset caused by core LOCKUP event
    */
    alias LOCKUP =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Software
      0  #0  Reset not caused by software setting of SYSRESETREQ bit
      1  #1  Reset caused by software setting of SYSRESETREQ bit
    */
    alias SW =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    MDM-AP System Reset Request
      0  #0  Reset not caused by host debugger system setting of the System Reset Request bit
      1  #1  Reset caused by host debugger system setting of the System Reset Request bit
    */
    alias MDM_AP =   Bit!(4, Mutability.read_only);

    /************************************************************************************
    Stop Mode Acknowledge Error Reset
      0  #0  Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
      1  #1  Reset caused by peripheral failure to acknowledge attempt to enter stop mode
    */
    alias SACKERR =   Bit!(6, Mutability.read_only);

  }
  /**************************************************************************************
  * Reset Pin Filter Control register
  */
  final abstract class RPFC  : Register!(0x4  , Access.read_write8)
  {
    /************************************************************************************
    Reset Pin Filter Select in Run and Wait Modes
      00  #00  All filtering disabled
      01  #01  Bus clock filter enabled for normal operation
      10  #10  LPO clock filter enabled for normal operation
    */
    alias RSTFLTSRW =   BitField!(2, 0, Mutability.read_write);

    /************************************************************************************
    Reset Pin Filter Select in Stop Mode
      0  #0  All filtering disabled
      1  #1  LPO clock filter enabled
    */
    alias RSTFLTSS =   Bit!(3, Mutability.read_write);

  }
  /**************************************************************************************
  * Reset Pin Filter Width register
  */
  final abstract class RPFW  : Register!(0x5  , Access.read_write8)
  {
    /************************************************************************************
    Reset Pin Filter Bus Clock Select
      00000  #00000  Bus clock filter count is 1
      00001  #00001  Bus clock filter count is 2
      00010  #00010  Bus clock filter count is 3
      00011  #00011  Bus clock filter count is 4
      00100  #00100  Bus clock filter count is 5
      00101  #00101  Bus clock filter count is 6
      00110  #00110  Bus clock filter count is 7
      00111  #00111  Bus clock filter count is 8
      01000  #01000  Bus clock filter count is 9
      01001  #01001  Bus clock filter count is 10
      01010  #01010  Bus clock filter count is 11
      01011  #01011  Bus clock filter count is 12
      01100  #01100  Bus clock filter count is 13
      01101  #01101  Bus clock filter count is 14
      01110  #01110  Bus clock filter count is 15
      01111  #01111  Bus clock filter count is 16
      10000  #10000  Bus clock filter count is 17
      10001  #10001  Bus clock filter count is 18
      10010  #10010  Bus clock filter count is 19
      10011  #10011  Bus clock filter count is 20
      10100  #10100  Bus clock filter count is 21
      10101  #10101  Bus clock filter count is 22
      10110  #10110  Bus clock filter count is 23
      10111  #10111  Bus clock filter count is 24
      11000  #11000  Bus clock filter count is 25
      11001  #11001  Bus clock filter count is 26
      11010  #11010  Bus clock filter count is 27
      11011  #11011  Bus clock filter count is 28
      11100  #11100  Bus clock filter count is 29
      11101  #11101  Bus clock filter count is 30
      11110  #11110  Bus clock filter count is 31
      11111  #11111  Bus clock filter count is 32
    */
    alias RSTFLTSEL =   BitField!(5, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class GPIOA: Peripheral!(0x400FF000)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class GPIOB: Peripheral!(0x400FF040)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class GPIOC: Peripheral!(0x400FF080)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class GPIOD: Peripheral!(0x400FF0C0)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class GPIOE: Peripheral!(0x400FF100)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * Micro Trace Buffer
*/
final abstract class MTB: Peripheral!(0xF0000000)
{
  /**************************************************************************************
  * MTB Position Register
  */
  final abstract class POSITION  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias WRAP =   Bit!(3, Mutability.read_write);

    /************************************************************************************
    Trace Packet Address Pointer
    */
    alias POINTER =   BitField!(32, 3, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB Master Register
  */
  final abstract class MASTER  : Register!(0x4  , Access.read_write32)
  {
    /************************************************************************************
    Mask
    */
    alias MASK =   BitField!(5, 0, Mutability.read_write);

    /************************************************************************************
    Trace start input enable
    */
    alias TSTARTEN =   Bit!(6, Mutability.read_write);

    /************************************************************************************
    Trace stop input enable
    */
    alias TSTOPEN =   Bit!(7, Mutability.read_write);

    /************************************************************************************
    Special Function Register Write Privilege bit
    */
    alias SFRWPRIV =   Bit!(8, Mutability.read_write);

    /************************************************************************************
    RAM privilege bit
    */
    alias RAMPRIV =   Bit!(9, Mutability.read_write);

    /************************************************************************************
    Halt request bit
    */
    alias HALTREQ =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Main trace enable bit
    */
    alias EN =   Bit!(32, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB Flow Register
  */
  final abstract class FLOW  : Register!(0x8  , Access.read_write32)
  {
    /************************************************************************************
    no description available
    */
    alias AUTOSTOP =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    no description available
    */
    alias AUTOHALT =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    WATERMARK value
    */
    alias WATERMARK =   BitField!(32, 3, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB Base Register
  */
  final abstract class BASE  : Register!(0xC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias BASEADDR =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Integration Mode Control Register
  */
  final abstract class MODECTRL  : Register!(0xF00  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias MODECTRL =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Claim TAG Set Register
  */
  final abstract class TAGSET  : Register!(0xFA0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias TAGSET =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Claim TAG Clear Register
  */
  final abstract class TAGCLEAR  : Register!(0xFA4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias TAGCLEAR =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Lock Access Register
  */
  final abstract class LOCKACCESS  : Register!(0xFB0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias LOCKACCESS =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Lock Status Register
  */
  final abstract class LOCKSTAT  : Register!(0xFB4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias LOCKSTAT =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Authentication Status Register
  */
  final abstract class AUTHSTAT  : Register!(0xFB8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias BIT0 =   Bit!(1, Mutability.read_only);

    /************************************************************************************
    no description available
    */
    alias BIT1 =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    no description available
    */
    alias BIT2 =   Bit!(3, Mutability.read_only);

    /************************************************************************************
    no description available
    */
    alias BIT3 =   Bit!(4, Mutability.read_only);

  }
  /**************************************************************************************
  * Device Architecture Register
  */
  final abstract class DEVICEARCH  : Register!(0xFBC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias DEVICEARCH =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Device Configuration Register
  */
  final abstract class DEVICECFG  : Register!(0xFC8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias DEVICECFG =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Device Type Identifier Register
  */
  final abstract class DEVICETYPID  : Register!(0xFCC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias DEVICETYPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID4  : Register!(0XFD0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID5  : Register!(0XFD4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID6  : Register!(0XFD8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID7  : Register!(0XFDC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID0  : Register!(0XFE0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID1  : Register!(0XFE4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID2  : Register!(0XFE8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID3  : Register!(0XFEC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID0  : Register!(0XFF0  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID1  : Register!(0XFF4  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID2  : Register!(0XFF8  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID3  : Register!(0XFFC  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
}
/****************************************************************************************
  * MTB data watchpoint and trace
*/
final abstract class MTBDWT: Peripheral!(0xF0001000)
{
  /**************************************************************************************
  * MTB DWT Control Register
  */
  final abstract class CTRL  : Register!(0  , Access.read_only32)
  {
    /************************************************************************************
    DWT configuration controls
    */
    alias DWTCFGCTRL =   BitField!(28, 0, Mutability.read_only);

    /************************************************************************************
    Number of comparators
    */
    alias NUMCMP =   BitField!(32, 28, Mutability.read_only);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Register
  */
  final abstract class COMP0  : Register!(0X20  , Access.read_write32)
  {
    /************************************************************************************
    Reference value for comparison
    */
    alias COMP =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Register
  */
  final abstract class COMP1  : Register!(0X30  , Access.read_write32)
  {
    /************************************************************************************
    Reference value for comparison
    */
    alias COMP =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Mask Register
  */
  final abstract class MASK0  : Register!(0X24  , Access.read_write32)
  {
    /************************************************************************************
    MASK
    */
    alias MASK =   BitField!(5, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Mask Register
  */
  final abstract class MASK1  : Register!(0X34  , Access.read_write32)
  {
    /************************************************************************************
    MASK
    */
    alias MASK =   BitField!(5, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Function Register 0
  */
  final abstract class FCT0  : Register!(0x28  , Access.read_write32)
  {
    /************************************************************************************
    Function
      0000  #0000  Disabled.
      0100  #0100  Instruction fetch.
      0101  #0101  Data operand read.
      0110  #0110  Data operand write.
      0111  #0111  Data operand (read + write).
    */
    alias FUNCTION =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    Data Value Match
      0  #0  Perform address comparison.
      1  #1  Perform data value comparison.
    */
    alias DATAVMATCH =   Bit!(9, Mutability.read_write);

    /************************************************************************************
    Data Value Size
      00  #00  Byte.
      01  #01  Halfword.
      10  #10  Word.
      11  #11  Reserved. Any attempts to use this value results in UNPREDICTABLE behavior.
    */
    alias DATAVSIZE =   BitField!(12, 10, Mutability.read_write);

    /************************************************************************************
    Data Value Address 0
    */
    alias DATAVADDR0 =   BitField!(16, 12, Mutability.read_write);

    /************************************************************************************
    Comparator match
      0  #0  No match.
      1  #1  Match occurred.
    */
    alias MATCHED =   Bit!(25, Mutability.read_only);

  }
  /**************************************************************************************
  * MTB_DWT Comparator Function Register 1
  */
  final abstract class FCT1  : Register!(0x38  , Access.read_write32)
  {
    /************************************************************************************
    Function
      0000  #0000  Disabled.
      0100  #0100  Instruction fetch.
      0101  #0101  Data operand read.
      0110  #0110  Data operand write.
      0111  #0111  Data operand (read + write).
    */
    alias FUNCTION =   BitField!(4, 0, Mutability.read_write);

    /************************************************************************************
    Comparator match
      0  #0  No match.
      1  #1  Match occurred.
    */
    alias MATCHED =   Bit!(25, Mutability.read_only);

  }
  /**************************************************************************************
  * MTB_DWT Trace Buffer Control Register
  */
  final abstract class TBCTRL  : Register!(0x200  , Access.read_write32)
  {
    /************************************************************************************
    Action based on Comparator 0 match
      0  #0  Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].
      1  #1  Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].
    */
    alias ACOMP0 =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Action based on Comparator 1 match
      0  #0  Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].
      1  #1  Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].
    */
    alias ACOMP1 =   Bit!(2, Mutability.read_write);

    /************************************************************************************
    Number of Comparators
    */
    alias NUMCOMP =   BitField!(32, 28, Mutability.read_only);

  }
  /**************************************************************************************
  * Device Configuration Register
  */
  final abstract class DEVICECFG  : Register!(0xFC8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias DEVICECFG =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Device Type Identifier Register
  */
  final abstract class DEVICETYPID  : Register!(0xFCC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias DEVICETYPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID4  : Register!(0XFD0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID5  : Register!(0XFD4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID6  : Register!(0XFD8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID7  : Register!(0XFDC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID0  : Register!(0XFE0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID1  : Register!(0XFE4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID2  : Register!(0XFE8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID3  : Register!(0XFEC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID0  : Register!(0XFF0  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID1  : Register!(0XFF4  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID2  : Register!(0XFF8  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID3  : Register!(0XFFC  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
}
/****************************************************************************************
  * System ROM
*/
final abstract class ROM: Peripheral!(0xF0002000)
{
  /**************************************************************************************
  * Entry
  */
  final abstract class ENTRY0  : Register!(0  , Access.read_only32)
  {
    /************************************************************************************
    ENTRY
    */
    alias ENTRY =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Entry
  */
  final abstract class ENTRY1  : Register!(0X4  , Access.read_only32)
  {
    /************************************************************************************
    ENTRY
    */
    alias ENTRY =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Entry
  */
  final abstract class ENTRY2  : Register!(0X8  , Access.read_only32)
  {
    /************************************************************************************
    ENTRY
    */
    alias ENTRY =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * End of Table Marker Register
  */
  final abstract class TABLEMARK  : Register!(0xC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias MARK =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * System Access Register
  */
  final abstract class SYSACCESS  : Register!(0xFCC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias SYSACCESS =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID4  : Register!(0XFD0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID5  : Register!(0XFD4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID6  : Register!(0XFD8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID7  : Register!(0XFDC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID0  : Register!(0XFE0  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID1  : Register!(0XFE4  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID2  : Register!(0XFE8  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Peripheral ID Register
  */
  final abstract class PERIPHID3  : Register!(0XFEC  , Access.read_only32)
  {
    /************************************************************************************
    no description available
    */
    alias PERIPHID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID0  : Register!(0XFF0  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID1  : Register!(0XFF4  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID2  : Register!(0XFF8  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Component ID Register
  */
  final abstract class COMPID3  : Register!(0XFFC  , Access.read_only32)
  {
    /************************************************************************************
    Component ID
    */
    alias COMPID =   BitField!(32, 0, Mutability.read_only);

  }
}
/****************************************************************************************
  * Core Platform Miscellaneous Control Module
*/
final abstract class MCM: Peripheral!(0xF0003000)
{
  /**************************************************************************************
  * Crossbar Switch (AXBS) Slave Configuration
  */
  final abstract class PLASC  : Register!(0x8  , Access.read_only16)
  {
    /************************************************************************************
    Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
      0  #0  A bus slave connection to AXBS input port n is absent
      1  #1  A bus slave connection to AXBS input port n is present
    */
    alias ASC =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Crossbar Switch (AXBS) Master Configuration
  */
  final abstract class PLAMC  : Register!(0xA  , Access.read_only16)
  {
    /************************************************************************************
    Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
      0  #0  A bus master connection to AXBS input port n is absent
      1  #1  A bus master connection to AXBS input port n is present
    */
    alias AMC =   BitField!(8, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Platform Control Register
  */
  final abstract class PLACR  : Register!(0xC  , Access.read_write32)
  {
    /************************************************************************************
    Arbitration select
      0  #0  Fixed-priority arbitration for the crossbar masters
      1  #1  Round-robin arbitration for the crossbar masters
    */
    alias ARB =   Bit!(10, Mutability.read_write);

    /************************************************************************************
    Clear Flash Controller Cache
    */
    alias CFCC =   Bit!(11, Mutability.write_only);

    /************************************************************************************
    Disable Flash Controller Data Caching
      0  #0  Enable flash controller data caching
      1  #1  Disable flash controller data caching.
    */
    alias DFCDA =   Bit!(12, Mutability.read_write);

    /************************************************************************************
    Disable Flash Controller Instruction Caching
      0  #0  Enable flash controller instruction caching.
      1  #1  Disable flash controller instruction caching.
    */
    alias DFCIC =   Bit!(13, Mutability.read_write);

    /************************************************************************************
    Disable Flash Controller Cache
      0  #0  Enable flash controller cache.
      1  #1  Disable flash controller cache.
    */
    alias DFCC =   Bit!(14, Mutability.read_write);

    /************************************************************************************
    Enable Flash Data Speculation
      0  #0  Disable flash data speculation.
      1  #1  Enable flash data speculation.
    */
    alias EFDS =   Bit!(15, Mutability.read_write);

    /************************************************************************************
    Disable Flash Controller Speculation
      0  #0  Enable flash controller speculation.
      1  #1  Disable flash controller speculation.
    */
    alias DFCS =   Bit!(16, Mutability.read_write);

    /************************************************************************************
    Enable Stalling Flash Controller
      0  #0  Disable stalling flash controller when flash is busy.
      1  #1  Enable stalling flash controller when flash is busy.
    */
    alias ESFC =   Bit!(17, Mutability.read_write);

  }
  /**************************************************************************************
  * Compute Operation Control Register
  */
  final abstract class CPO  : Register!(0x40  , Access.read_write32)
  {
    /************************************************************************************
    Compute Operation request
      0  #0  Request is cleared.
      1  #1  Request Compute Operation.
    */
    alias CPOREQ =   Bit!(1, Mutability.read_write);

    /************************************************************************************
    Compute Operation acknowledge
      0  #0  Compute operation entry has not completed or compute operation exit has completed.
      1  #1  Compute operation entry has completed or compute operation exit has not completed.
    */
    alias CPOACK =   Bit!(2, Mutability.read_only);

    /************************************************************************************
    Compute Operation wakeup on interrupt
      0  #0  No effect.
      1  #1  When set, the CPOREQ is cleared on any interrupt or exception vector fetch.
    */
    alias CPOWOI =   Bit!(3, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class FGPIOA: Peripheral!(0xF80FF000)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class FGPIOB: Peripheral!(0xF80FF040)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class FGPIOC: Peripheral!(0xF80FF080)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class FGPIOD: Peripheral!(0xF80FF0C0)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
/****************************************************************************************
  * General Purpose Input/Output
*/
final abstract class FGPIOE: Peripheral!(0xF80FF100)
{
  /**************************************************************************************
  * Port Data Output Register
  */
  final abstract class PDOR  : Register!(0  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Output
      0  #0  Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
      1  #1  Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
    */
    alias PDO =   BitField!(32, 0, Mutability.read_write);

  }
  /**************************************************************************************
  * Port Set Output Register
  */
  final abstract class PSOR  : Register!(0x4  , Access.write_only32)
  {
    /************************************************************************************
    Port Set Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to logic 1.
    */
    alias PTSO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Clear Output Register
  */
  final abstract class PCOR  : Register!(0x8  , Access.write_only32)
  {
    /************************************************************************************
    Port Clear Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is cleared to logic 0.
    */
    alias PTCO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Toggle Output Register
  */
  final abstract class PTOR  : Register!(0xC  , Access.write_only32)
  {
    /************************************************************************************
    Port Toggle Output
      0  #0  Corresponding bit in PDORn does not change.
      1  #1  Corresponding bit in PDORn is set to the inverse of its existing logic state.
    */
    alias PTTO =   BitField!(32, 0, Mutability.write_only);

  }
  /**************************************************************************************
  * Port Data Input Register
  */
  final abstract class PDIR  : Register!(0x10  , Access.read_only32)
  {
    /************************************************************************************
    Port Data Input
      0  #0  Pin logic level is logic 0, or is not configured for use by digital function.
      1  #1  Pin logic level is logic 1.
    */
    alias PDI =   BitField!(32, 0, Mutability.read_only);

  }
  /**************************************************************************************
  * Port Data Direction Register
  */
  final abstract class PDDR  : Register!(0x14  , Access.read_write32)
  {
    /************************************************************************************
    Port Data Direction
      0  #0  Pin is configured as general-purpose input, for the GPIO function.
      1  #1  Pin is configured as general-purpose output, for the GPIO function.
    */
    alias PDD =   BitField!(32, 0, Mutability.read_write);

  }
}
